\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[estonian]{babel}
\usepackage{cite}

\title{Alglaadur ESTCube-1 käsu- ja andmehaldussüsteemile ja kaameramoodulile}
\author{Karl Tarbe}


\newcommand{\iic}{I\({}^2\)C }

\begin{document}
\begin{titlepage}
\begin{center}
Tartu Ülikool\\
Matemaatika-informaatika teaduskond\\
Arvutiteaduse instituut\\
Informaatika eriala
\vfill
Karl Tarbe\\[1cm]
Alglaadur ESTCube-1 käsu- ja andmehaldussüsteemile ja kaameramoodulile\\[4mm]
Bakalaureusetöö (6 EAP)
\vspace{2cm}
\begin{flushright}
	Juhendajad: Meelis Roos\\
	Helle Hein
\end{flushright}
\vfill
Tartu 2013
\end{center}
\end{titlepage}
\tableofcontents

\section{Sissejuhatus}
Aasta 2008 suvel alustati tudengisatelliidi projektiga. Esialgu pidi tegemist
olema väga lihtsa satelliidiga, kus peal on võib-olla üks või kaks
mikrokontrollerit, kuid asjad nii ei läinud. Inseneridele meeldib ikka üle
töötada ja asju paremaks teha. Nii sai ka eesti esimesest satelliidist päris
keeruline süsteem, mis koosneb mitmetest moodulitest. Kuna tegemist on üpris
keerulise süsteemiga peab ka selle juhtimiseks kasutatav tarkvara keeruline
olema ja iga keerulise tarkvara puhul esineb tavaliselt vigu. Siinkohal muutubki
aktuaalseks alglaadur, mille abil saab tarkvara uuendada.

\subsection{Estcube-1}
\subsubsection{Missioon}
\subsection{Käsu- ja andmehaldussüsteem - CDHS}
\textit{Command and Data Handling System} ehk käsu- ja andmehaldussüsteem on
kavandatud satelliidi peamiseks pardaarvutiks. Peamised arvutused, mis määravad
satelliidi positsiooni, toimuvad just CDHSis. CDHSi salvestatakse igasugu
erinevaid andmeid, mida sõltuvalt maapealt tulevatele käskudele ka tagastatakse.

Süsteem koosneb nii tarkvarast kui ka elektroonikast, mille peal tarkvara
jooksutatakse. Antud bakalauresetöö raames pole põhitarkvara detailid eriti
olulised, aga elektroonika on natuke oluline. Nimelt kuuluvad CDHSi juurde ka
mitmed mälud, kus hoitakse erinevaid andmeid. Nendest mäludest oluliseks on
Ferroelektrilised juhupöördusega mälud (FRAM), sest need on radiatsioonirikkas
keskkonnas mitu korda töökindlamad kui tavapärased välkmälud (FLASH). Täpsemalt
on mäludest juttu peatükis~\ref{sec:m2lud}.

Protsessorituumaks on ARM Cortex-M3, mis paikneb STMicroelectronics-i poolt
valmistatud mikrokontrolleris STM32F107, millest tuleb lähemalt juttu
peatükis~\ref{sec:mcu}. Üheks märkimisväärseks omaduseks CDHSi puhul on see, et
süsteemis on osaline riistvaraline dubleeritus: trükkplaadil on kaks identset
mikrokontrollerit. Esialgu jookseb neist üks, kuid kui tuvastatakse, et see
mikrokontroller enam ei tööta, lülitatakse ümber teisele mikrokontrollerile.
Selle vea tuvastamise ja ümberlülitamise eest vastutab toitesüsteem. Lülitatakse
ümber ka andmesiinid, sest mikrokontrollerist väljajäävad seadmed on korraga
ühenduses ainult ühe mikrokontrolleriga.

\subsection{Kaameramoodul - CAM}
Kaameramooduli ülesandeks on teha pilte kontrollimaks, kas päikesepurje
veljakerimine õnnestub nii nagu soovitud. Sekundaarne ülesanne on teha maast ja
ka eestist pilte, mida saaks kasutada teaduse populariseerimise eesmärgil.
Pilte saab teha VGA resolutsioonis ehk 640\(\times\)480 pikslit, mida on üldises
mõttes küll väga vähe, kuid loodetavasti piisavalt, et etteantud ülesandeid
täita.

Sarnaselt CDHSiga juhib mooduli tööd mikrokontroller, mille tootjaks on
STMicroelectronics. Mikrokontrolleriks on STM32F217, mis laias laastus ei erine
eriti CDHSi peal kasutatavast STM32F107st, kuid nendest erinevustest lähemalt
saab lugeda peatükist~\ref{sec:mcu}.

Teine sarnasus CDHSiga on see, et ka CAMil on mikrokontrollerist väljajäävad
mälud. Täpsemalt on alglaaduri jaoks oluline, et CAMil asub FRAM tüüpi mälu,
millega mikrokontroller saab suhelda üle \iic andmesiini.

\subsection{Mälud}
\label{sec:m2lud}
SRAM
FRAM vs FLASH

\subsection{Mikrokontrollerid STM32F107 ja STM32F217}
\label{sec:mcu}
Mikrokontrollerid STM32F107 ja STM32F217 on mõlemad STMicroelectronics-i tooted,
mida kasutatakse vastavalt CDHSil ja CAMil. Üldiselt kogu järgnev tekst siin
alapeatükis viitab mikrokontrollerite tehnilistele manuaalidele
\cite{f1rm,f2rm}. Esimene alamosa kirjeldab kontrollerite ühisosa ja teine
kirjeldab nende erinevusi. Alglaaduri tööks mittevajalikud osad jäävad
kirjeldamata.
\subsubsection{Sarnasused}
Neis mõlemas on protsessorituumaks ARM arhitektuuriga Cortex-M3, mis on väga
tihedalt seotud katkestustekontrolleriga. Täpsemalt selle kohta saab lugeda
manuaalist \cite{CM3pm}.

Mikrokontroller erineb mikroprotsessorist just selle poolest, et lisaks
mikroprotsessorile on mikrokontrolleris olemas ka ülejäänud vajalik, et tööd
teha: operatiivmälu, mälu tarkvara masinkoodi jaoks ja mitmed moodulid välise
maailmaga või väliste seadmetega suhtlemiseks. Mõned moodulid, mida alglaadur
oma töös kasutab aga on õnneks kasutamise seisukohalt täpselt samasugused.

Üheks selliseks mooduliks on kontrollsumma arvutamise üksus (\textit{CRC
calculation unit}), mille abil saab efektiivselt arvutada 32 bitist
kontrollsummat(CRC-32). On mitmeid erinevaid standardeid, mille järgi CRC-32te
arvutada. Antud moodul kasutab Ethernet-is ja mujal kasutusel olevat polünoomi,
mille väärtus kuueteistkümnendsüsteemis on 0x4C11DB7. 

Kuna alglaadur peab suhtlema väliste mäludega üle \iic ja SPI andmesiinide on
oluline ka see, et mõlema jaoks on eraldi moodulid olemas. Ilma eraldiasuva
moodulita peaks raiskama protsessoriaega, et ükshaaval erinevaid sisend-väljund
viike juhtida, mis on küll võimalik, kuid ebaefektiivne, sest protsessor peab
ühe andmevahetuse kella takti jooksul täitma mitmeid instruktsioone ja seega
on andmevahetuse üldine kellasagedus kümneid kuni sadu kordi aeglasem, kui
protsessori kellasagedus.

Ja lõpetuseks võib öelda, et alglaadimise protseduur on mõlemal kontrolleril
samasugune ja see on kirjeldatud peatükis~\ref{sec:boot}.

\subsubsection{Erinevused}
Esimeseks alglaaduri seisukohalt väheoluliseks erinevuseks on see, et
maksimaalne lubatud töösagedus protsessorile on STM32F107 korral 72MHz ning
STM32F217 korral 120MHz. Alglaaduri seisukohalt pole see oluline, sest alglaadur
kasutab kogu oma töö vältel madala sagedusega sisemist kellasignaali.

Alglaaduri seisukohalt oluliseks erinevuseks on aga sisemise välkmälu erinev
ülesehitus. STM32F107l on välkmälu jagatud kaheks mälupangaks (\textit{memory
bank}), millele on juurdepääsuks erinevad registrid, aga STM32F217l on üks
mälupank. Lisaks sellele on esimese kontrolleri puhul kõik mälulehed sama
suurusega, kuid ühe mälupangaga kontrolleris on mälulehtede suurused
varieeruvad. \cite{f1fpm,f2fpm}

Lisaks sellele on erinev sisend-väljund viikude seadistamine. Erinev on nii
lihtsalt viikude seadistamine kui ka mingite konkreetsete viikude seadistamine
nii, et riistvaralised moodulid saaksid neid kasutada.

\section{Süsteemi nõuded}

\section{Alglaadimine}
\label{sec:boot}
\subsection{Tavapärane alglaadimisprotseduur}
Kui mikrokontrolleril toide olemas on üritab see ennast tööle panna.
Esmalt lülitatakse sisse sisemine 8-MHz-ne ossillaator, mille signaali
neljandal tõusval frondil loetakse konfigureerimise viikude väärtused. Nende
väärtuste põhjal otsustatakse, millisest kohast alglaadida. Võimalikud
variandid on: põhi välkmälu, süsteemi mälu ja staatiline juhupöördlusega
mälu(SRAM).  Enim kasutatakse kahte esimest: põhi välkmälu seal oleva programmi
käivitamiseks ja süsteemi mälu, et põhimälu muuta. Tehases paigaldatakse
süsteemi mällu, mis on tegelikult lihtsalt üks kaitstud osa põhi välkmälu
lõpust, alglaadur, mille abil saab programmeerida ülejäänud välkmälu ehk oma
programmi mikrokontrollerile laadida.

Oletades, et programm on juba kiibi välkmälus olemas ja alglaadimist
alustatakse põhi välkmälust, vaatleme edasist protsessi. Välkmälu aadress on
tegelikult 0x800 0000, aga viikude oleku tõttu peegeldatakse see ka aadressile
0x0000 0000, kust protsessor oma tööd alustab.  Protsessor võtab aadressil
0x0000 0000 oleva väärtuse ja seab selle pinu ülemiseks väärtuseks. Seejärel
alustatakse instruktsioonide täitmist lähtestamise vektorist, mille
algusaadress on kirjas aadressil 0x0000 0004. \cite{f1rm}

Lähtestamise vektoril on tavaliselt assembleris kirjutatud protseduur, mis
kopeerib programmi andmete sektsiooni välkmälust SRAMi, täidab ülejäänud
programmi jaoks vajaliku ala SRAMist nullidega, kutsub välja C koodis kirjutatud
protseduuri, mis initsialiseerib süsteemi kella, ja siis annab juhtimise üle C
koodis kirjutatud \textit{main} protseduurile. Satelliidi peal ei kasutata
üldist kella seadmise koodi ja seega see samm jäetakse vahele ning kella
seadmine kutsutakse välja \textit{main}ist.

See, mida tarkvara edasi initisaliseerib, on juba tarkvara spetsiifiline.
Tõenäoliselt initsialiseeritakse mõned riistvaralised moodulid näiteks USART või
SPI ja hakatakse siis rakendusele vajalikku kontrolltsüklit täitma. Satelliidil
Estcube-1 kasutatakse nii CAMil kui ka CDHSil reaalaja operatsioonisüsteemi
FreeRTOS.

\subsection{Programmi alglaadimine koos alglaaduriga}
Alglaadur ise käitub alglaadimise seisukohalt nagu iga teinegi programm ja
laetakse täpselt samamoodi nagu eelmises alapeatükis kirjeldatud. See tähendab
seda, et alglaaduri katkestusvektorite tabel peab asuma välkmälu alguses, sest
sealt hakkab protsessor seda otsima. Kuna üks osa alglaadurist asub juba
välkmälu alguses, on ka teised osad sinna järele paigutatud, mis omakorda
tähendab, et tegelik põhiprogramm peab nüüd asuma kusagil mujal kui välkmälu
alguses ja sellega peab arvestama põhiprogrammi linkimisel.

Kui alglaadur on oma muud ülesanded juba täitnud, on tema viimaseks tööks
põhitarkvara käivitamine. Selleks käitub sarnaselt protsessoriga, kuid
kõigepealt on tal vaja teada, mis aadressil põhitarkvara katkestusvektorite
tabel asub. See aadress on aga eelnevalt kokkulepitud ja sissekodeeritud.

Enne põhitarkvara töölepanemist tuleks puhtaks teha pinu. Alglaaduri enda töö
ajal sinna salvestatud väärtusi pole põhiprogrammil kohe kuidagi vaja. Pinu
puhtaks tegemine tähendab lihtsalt pinu viida algväärtustamist, sest nii
hakatakse edaspidi pinus juba olevaid andmeid üle kirjutama ja kui programm on
korrektne, siis midagi sellist ei loeta, mida programm ise pole juba üle
kirjutanud. Algväärtustamiseks kasutatakse põhitarkvara katkestusvektorite
tabeli esimest elementi, mis näitas pinu ülemist aadressi.

Kuigi mikrokontrolleri käivitamise hetkel alustatakse tööd kindlast kohast, ei
pea terve katkestusvektorite tabel välkmälu alguses olema. Katkestustega tegeleb
eraldi riistvara moodul NVIC (\textit{Nested Vectored Interrupt Controller}).
Lisaks on sellega tihedalt seotud teine moodul SCB (\textit{System Control
Block}), kus asub seadistatav register VTOR (\textit{Vector Table Offset
Register}), mille väärtust kasutatakse katkestusvektorite tabeli aadressina.
\cite[ptk~4.4]{CM3pm} Vaikimisi on seal väärtus 0x0000 0000, mida kasutatakse alglaaduri
laadimiseks, kuid alglaadur seab selleks väärtuseks põhiprogrammi
katkestusvektorite tabeli aadressi. Kui seda ei seadistataks, siis kutsutaks
põhiprogrammi katkestuse ajal välja alglaaduri katkestusvektoreid, mis on
tegelikult implementeerimata, sest alglaadur ei kasuta katkestusi, ja nii ei
saaks põhitarkvara oma ülesandeid täita. Lisaks sellele on vaikimisi katkestuse
teenindamise rutiin lihtsalt lõputu tsükkel, seega jääks kontroller katkestusse
kinni ja halvatud ei oleks ainult põhitarkvara katkestuse teenindamine vaid kogu
põhitarkvara töö peatuks.

Kui pinu viit ja katkestusvektorite tabeli asukoht on ära seadistatud jääb üle
veel lugeda katkestusvektorite tabelist põhiprogrammi lähtestamise vektori
aadress ja mikrokontrolleri töö sinna edasi juhtida. Selleks tehakse C-koodis
funktsiooni viit, mis väärtustatakse lähtestamise vektori aadressiga ning
seejärel kutsutakse see välja.

Edasine toimub sarnane tegevus nagu tavapärase alglaadimise juures, kus
lähtestamise vektoril olev kood kopeerib välkmälus oleva põhiprogrammi andmete
sekstsiooni SRAMi, tähendab SRAMi initsialiseerimata andmete jaoks ja seejärel
kutsub välja põhitarkvara \textit{main} protseduuri.


\section{Komponendid}

\section{Kokkuvõte}

\section{Resume}

\bibliographystyle{plain}
\bibliography{viited}

\end{document}
