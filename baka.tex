\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[estonian]{babel}
\usepackage{cite}
\usepackage[hidelinks]{hyperref}

\title{Alglaadur ESTCube-1 käsu- ja andmehaldussüsteemile ja kaameramoodulile}
\author{Karl Tarbe}


\newcommand{\iic}{I\({}^2\)C }

\begin{document}
\begin{titlepage}
\begin{center}
Tartu Ülikool\\
Matemaatika-informaatika teaduskond\\
Arvutiteaduse instituut\\
Informaatika eriala
\vfill
Karl Tarbe\\[1cm]
Alglaadur ESTCube-1 käsu- ja andmehaldussüsteemile ja kaameramoodulile\\[4mm]
Bakalaureusetöö (6 EAP)
\vspace{2cm}
\begin{flushright}
	Juhendajad: Meelis Roos\\
	Helle Hein
\end{flushright}
\vfill
Tartu 2013
\end{center}
\end{titlepage}
\tableofcontents

\section{Sissejuhatus}
Aasta 2008 suvel alustati tudengisatelliidi projektiga. Esialgu pidi tegemist
olema väga lihtsa satelliidiga, kus peal on võib-olla üks või kaks
mikrokontrollerit, kuid asjad nii ei läinud. Inseneridele meeldib ikka üle
töötada ja asju paremaks teha. Nii sai ka eesti esimesest satelliidist päris
keeruline süsteem, mis koosneb mitmetest moodulitest. Kuna tegemist on üpris
keerulise süsteemiga peab ka selle juhtimiseks kasutatav tarkvara keeruline
olema ja iga keerulise tarkvara puhul esineb tavaliselt vigu. Siinkohal muutubki
aktuaalseks alglaadur, mille abil saab tarkvara uuendada.

\subsection{Estcube-1}
\subsubsection{Missioon}
Aastal 2006 leiutati uudne viis, kuidas kasutada päikeselt tulevat laetud
osakeste voogu ehk päikesetuult liikumiseks. Selleks kasutatakse peenikesi
juhtmeid, mis pingestatakse päikesetuule suhtes. Sama laenguga osakesed tõukuvad
ja kokkuvõttes hakkab päikesetuul neid juhtmeid koos lennumasinaga edasi
tõukama. Analoogia põhjal tavalise tuulega kutsutakse seda juhtmete kimpu
elektriliseks päikesepurjeks. Uudne lähenemine on umbes 100 korda efektiivsem,
kui hetkel planeetidevahelisteks lendudeks sobivaimad ioonmootorid.
\cite{errpuri}

Estcube-1 missiooniks on esimest korda ajaloos katsetada elektrilist
päikesepurje kosmoses. Satelliidi pardal olev juhtmete kimp kaalub 0,2 grammi ja
on 20 meetri pikkune. Stardi ajal on juhtmed keritud kokku rulli peale, et
stardimõõtmetesse ära mahtuda. Maa orbiidil pannakse satelliit pöörlema ja
tsentrifugaaljõu toimel keritakse päikesepuri aeglaselt rullilt maha.
Elektriline mootor kerib rulli lahti ja tsentrifugaaljõu tõttu kaugeneb puri
satelliidist ühtlaselt.
\subsection{Käsu- ja andmehaldussüsteem - CDHS}
\textit{Command and Data Handling System} ehk käsu- ja andmehaldussüsteem on
kavandatud satelliidi peamiseks pardaarvutiks. Peamised arvutused, mis määravad
satelliidi positsiooni, toimuvad just CDHSis. CDHSi salvestatakse igasugu
erinevaid andmeid, mida sõltuvalt maapealt tulevatele käskudele ka tagastatakse.

Süsteem koosneb nii tarkvarast kui ka elektroonikast, mille peal tarkvara
jooksutatakse. Antud bakalauresetöö raames pole põhitarkvara detailid eriti
olulised, aga elektroonika on natuke oluline. Nimelt kuuluvad CDHSi juurde ka
mitmed mälud, kus hoitakse erinevaid andmeid. Nendest mäludest oluliseks on
Ferroelektrilised juhupöördusega mälud (FRAM), sest need on radiatsioonirikkas
keskkonnas mitu korda töökindlamad kui tavapärased välkmälud (FLASH). Täpsemalt
on mäludest juttu peatükis~\ref{sec:m2lud}.

Protsessorituumaks on ARM Cortex-M3, mis paikneb STMicroelectronics-i poolt
valmistatud mikrokontrolleris STM32F103, millest tuleb lähemalt juttu
peatükis~\ref{sec:mcu}. Üheks märkimisväärseks omaduseks CDHSi puhul on see, et
süsteemis on osaline riistvaraline dubleeritus: trükkplaadil on kaks identset
mikrokontrollerit. Esialgu jookseb neist üks, kuid kui tuvastatakse, et see
mikrokontroller enam ei tööta, lülitatakse ümber teisele mikrokontrollerile.
Selle vea tuvastamise ja ümberlülitamise eest vastutab toitesüsteem. Lülitatakse
ümber ka andmesiinid, sest mikrokontrollerist väljajäävad seadmed on korraga
ühenduses ainult ühe mikrokontrolleriga.

\subsection{Kaameramoodul - CAM}
Kaameramooduli ülesandeks on teha pilte kontrollimaks, kas päikesepurje
veljakerimine õnnestub nii nagu soovitud. Sekundaarne ülesanne on teha maast ja
ka eestist pilte, mida saaks kasutada teaduse populariseerimise eesmärgil.
Pilte saab teha VGA resolutsioonis ehk 640\(\times\)480 pikslit, mida on üldises
mõttes küll väga vähe, kuid loodetavasti piisavalt, et etteantud ülesandeid
täita.

Sarnaselt CDHSiga juhib mooduli tööd mikrokontroller, mille tootjaks on
STMicroelectronics. Mikrokontrolleriks on STM32F217, mis laias laastus ei erine
eriti CDHSi peal kasutatavast STM32F103st, kuid nendest erinevustest lähemalt
saab lugeda peatükist~\ref{sec:mcu}.

Teine sarnasus CDHSiga on see, et ka CAMil on mikrokontrollerist väljajäävad
mälud. Täpsemalt on alglaaduri jaoks oluline, et CAMil asub FRAM tüüpi mälu,
millega mikrokontroller saab suhelda üle \iic andmesiini.

\subsection{Mälud}
\label{sec:m2lud}
Alglaadur puutub kokku kolme tüüpi mäludega.

\subsubsection{Juhupöördusega staatiline mälu - SRAM}
Lühend SRAM tuleb inglise keelest \textit{Static Random Access Memory}. Tegemist
on hävimäluga ehk seal olevad andmed kaovad, kui mälul ei ole voolu. Mälu asub
mikrokontrolleri sees ja seda kasutab programm tavapärase operatiivmäluna.
Kasutusel olevad mikrokontrollerid lubavad sealt ka instruktsiooni käivitada,
aga seda funktsionaalsust alglaaduris ei kasutata.

\subsubsection{Välkmälu - Flash}
Tegemist on enimlevinud tehnoloogiaga säilmälude hulgas. Antud juhul paikneb
seda tüüpi mälu mikrokontrolleri sees. Seal asub tarkvara, mida mikroprotsessor
asub käivitama. Antud mikrokontrollerite puhul on mälu juhupöördusega nii
kirjutamiseks, kui ka lugemiseks, aga kirjutamiseks peab mälu olema eelnevalt
kustutatud ehk siis mälus peab olema eelnevalt vastava pikkusega ühtedest
koosnev bitijada. CDHSi peal kasutatava STM32F103 mikrokontrolleril toimub
välkmällusse kirjutamine alati 16 biti kaupa. CAMil kasutataval STM32F217l saab
valida järgnevate pikkuste vahel: 64, 32, 16 või 8 bitti \cite{f2fpm}. See valik
sõltub ka olemasolevast toitepingest, kuid et STM32F103 peal valikut ei ole ja
alglaadur peab mõlema peal töötama, siis sarnasuse huvides on valitud STM32F217
korral samuti 16 bitine pikkus.

Välkmälu on jagatud mälulehtedeks, mis võivad olla kõik sama suurusega nagu
STM32F103l või ka erineva suurusega nagu STM32F217l. Välkmälust kustutamine
toimub antud mikrokontrollerite puhul toimub kas terve mälu või ühe mälelehe
kaupa. Kusjuures kuigi sisuliselt on tegemist sama asjaga nimetatakse STM32F103
puhul mälulehti mälulehtedeks (\textit{memofy page}), aga STM32F217
dokumentatsioonis on kasutusel termin mälusektor (\textit{memory sector}).
\cite{f1fpm,f2fpm}

\subsubsection{Ferroelektriline juhupöördusega mälu - FRAM}
FRAM on nagu välkmälugi säilmälu, kuhu jäävad andmed alles ka siis, kui seadmelt
toide ära võtta. Nii CDHSil kui ka CAMil jääb FRAM mikrokontrollerist väljapoole
ja sellega tuleb suhelda üle SPI või \iic andmesiini.

FRAMil on mitmeid eeliseid välkmälu ees:
\begin{itemize}
	\item lubatud ülekirjutamise tsükleid on rohkem,
	\item voolutarve on kordades väiksem,
	\item kiirus on kordades parem,
	\item mälu on juhupöördusega,
	\item mälu on radiatsioonikindlam.
\end{itemize}
Kuid FRAMil on ka kaks miinust: esiteks on andmetihedus suhteliselt väike ja teiseks
on tema hind kõrgem. Seda tüüpi mälu kasutatakse satelliidil, sest see on
radiatsioonikindlam. \cite{fram}

\subsection{Mikrokontrollerid STM32F103 ja STM32F217}
\label{sec:mcu}
Mikrokontrollerid STM32F103 ja STM32F217 on mõlemad STMicroelectronics-i tooted,
mida kasutatakse vastavalt CDHSil ja CAMil. Üldiselt kogu järgnev tekst siin
alapeatükis viitab mikrokontrollerite tehnilistele manuaalidele
\cite{f1rm,f2rm}. Esimene alamosa kirjeldab kontrollerite ühisosa ja teine
kirjeldab nende erinevusi. Alglaaduri tööks mittevajalikud osad jäävad
kirjeldamata.
\subsubsection{Sarnasused}
Neis mõlemas on protsessorituumaks ARM arhitektuuriga Cortex-M3, mis on väga
tihedalt seotud katkestustekontrolleriga. Täpsemalt selle kohta saab lugeda
manuaalist \cite{CM3pm}.

Mikrokontroller erineb mikroprotsessorist just selle poolest, et lisaks
mikroprotsessorile on mikrokontrolleris olemas ka ülejäänud vajalik, et tööd
teha: operatiivmälu, mälu tarkvara masinkoodi jaoks ja mitmed moodulid välise
maailmaga või väliste seadmetega suhtlemiseks. Mõned moodulid, mida alglaadur
oma töös kasutab aga on õnneks kasutamise seisukohalt täpselt samasugused.

Üheks selliseks mooduliks on kontrollsumma arvutamise üksus (\textit{CRC
calculation unit}), mille abil saab efektiivselt arvutada 32 bitist
kontrollsummat(CRC-32). On mitmeid erinevaid standardeid, mille järgi CRC-32te
arvutada. Antud moodul kasutab Ethernet-is ja mujal kasutusel olevat polünoomi,
mille väärtus kuueteistkümnendsüsteemis on 0x4C11DB7. 

Kuna alglaadur peab suhtlema väliste mäludega üle \iic ja SPI andmesiinide on
oluline ka see, et mõlema jaoks on eraldi moodulid olemas. Ilma eraldiasuva
moodulita peaks raiskama protsessoriaega, et ükshaaval erinevaid sisend-väljund
viike juhtida, mis on küll võimalik, kuid ebaefektiivne, sest protsessor peab
ühe andmevahetuse kella takti jooksul täitma mitmeid instruktsioone ja seega
on andmevahetuse üldine kellasagedus kümneid kuni sadu kordi aeglasem, kui
protsessori kellasagedus.

Ja lõpetuseks võib öelda, et alglaadimise protseduur on mõlemal kontrolleril
samasugune ja see on kirjeldatud peatükis~\ref{sec:boot}.

\subsubsection{Erinevused}
Esimeseks alglaaduri seisukohalt väheoluliseks erinevuseks on see, et
maksimaalne lubatud töösagedus protsessorile on STM32F103 korral 72MHz ning
STM32F217 korral 120MHz. Alglaaduri seisukohalt pole see oluline, sest alglaadur
kasutab kogu oma töö vältel madala sagedusega sisemist kellasignaali.

Alglaaduri seisukohalt oluliseks erinevuseks on aga sisemise välkmälu erinev
ülesehitus. STM32F103l on välkmälu jagatud kaheks mälupangaks (\textit{memory
bank}), millele on juurdepääsuks erinevad registrid, aga STM32F217l on üks
mälupank. Lisaks sellele on esimese kontrolleri puhul kõik mälulehed sama
suurusega, kuid ühe mälupangaga kontrolleris on mälulehtede suurused
varieeruvad. \cite{f1fpm,f2fpm}

Lisaks sellele on erinev sisend-väljund viikude seadistamine. Erinev on nii
lihtsalt viikude seadistamine kui ka mingite konkreetsete viikude seadistamine
nii, et riistvaralised moodulid saaksid neid kasutada.

\section{Süsteemi nõuded}
todo: nõuete kirjeldused koos põhjendustega.
\subsection{Kasutusjuhud}

\subsubsection{Vaikimisi alglaadimine}
\begin{enumerate}
\item Protsessor laeb alglaaduri
	\begin{enumerate}
	\item Kõik lisaseadmed ja riistvaramoodulid lülitatakse välja.
	\item Kõik viigud seatakse analoogsisendiks.
	\item Valvekoera taimer (\textit{Watchdog Timer}) seadistatakse.
	\item Lihtsad \iic FRAMi ajurid laetakse.
	\item Kontrollsumma moodul seadistatakse.
	\item Südamelöögi signaal seadistatakse.
	\item Alglaadur kontrollib iseenda kontrollsummat.
	\item Alglaadur võtab esimese käsu, valideerib ja täidab selle.
	\item CDHSi tarkvara alglaetakse.
	\item CDHSi tarkvara loeb alglaaduri logi ja kopeerib sealt tema jaoks
		huvitavad elemendid oma vigade logisse.
	\end{enumerate}
\end{enumerate}

\subsubsection{CDHSi tarkvara uuendamine}
\begin{enumerate}
	\item Uue tarkvara pilt hoiustatakse välises FRAMis ning CDHS
		taaskäivitatakse koos
		\begin{enumerate}
			\item käsuga alglaadurile, et kopeerida see mikrokontrolleri
				sisemisse välkmälusse.
		\end{enumerate}
	\item Alglaadur võtab esimese käsu ja täidab selle.
		\begin{enumerate}
			\item Käsuks on kopeerida tarkvara pilt välimisest FRAMi pesast \(X\)
				sisemisse välkmälu pessa \(Y\).
				\begin{enumerate}
					\item Arvutatakse pesas \(X\) oleva pildi kontrollsumma ja
						võrreldakse seda pesa \(X\) päises olevaga.
						\begin{enumerate}
							\item Kopeeritakse tarkvara pilt pesast \(X\) pesasse \(Y\).
							\item Kontrollitakse tarkvara pilti pesas \(Y\) ja
								vajadusel korratakse kopeerimist kuni kolm
								korda.
							\item Logitakse õnnestumine.
						\end{enumerate}
				\end{enumerate}
		\end{enumerate}
\end{enumerate}

\subsubsection{Välisest FRAMist lugemine ebaõnnestub}
\begin{enumerate}
	\item Alglaadur käivitatakse koos käsuga kopeerida tarkvara pilt välisest
		FRAMist.
	\item Alglaadur üritab lugeda välisest FRAMist.
		\begin{enumerate}
		\item Oletame, et FRAM ei vasta, või \iic andmesiin on hõivatud.
		\end{enumerate}
	\item \iic viga logitakse.
	\item Käskude nimekiri tühjendatakse.
	\item Alglaadur alglaeb vaikimisi pesas oleva tarkvara.
\end{enumerate}

\subsubsection{Kontrollsumma erinevus tarkvara pildil}
\begin{enumerate}
	\item Alglaaduril küsitakse opereerida tarkvara pildiga (kas kopeerida või
		alglaadida).
	\item Alglaadur arvutab tarkvara pildi kontrollsumma.
	\item Alglaadur võrdleb seda tarkvara pildi päises oleva kontrollsummaga.
		\begin{enumerate}
			\item Oletame, et need ei ühti.
		\end{enumerate}
	\item Viga logitakse.
	\item Käskude nimekiri tühjendatakse.
	\item Alglaadur valib vaikimisi tarkvara pildi ja proovib seda alglaadida.
\end{enumerate}

\subsubsection{Käskude nimekirjas on tundmatu käsk}
\begin{enumerate}
	\item Alglaadur vaatab käskude nimekirja.
		\begin{enumerate}
			\item Ja see ei ole tühi.
		\end{enumerate}
	\item Alglaadur võtab esimese käsu nimekirjast.
	\item Proovib seda verifitseerida, kuid ebaõnnestub.
	\item Alglaadur logib vea.
	\item Käskude nimekiri tühjendatakse.
	\item Alglaadur valib vaikimisi tarkvara pildi ja proovib seda alglaadida.
\end{enumerate}

\subsubsection{Soovitud tarkvara pilt valitakse FIRMW viigu abil}
\begin{enumerate}
	\item Alglaadur vaatab käskude nimekirja.
	\item Käskude nimekiri on tühi.
	\item Alglaadur vaatab FIRMW viiku.
		\begin{enumerate}
			\item See on madal?
				\begin{enumerate}
					\item Jah, siis laetakse vaikimisi pesas olev tarkvara.
				\end{enumerate}
			\item See on kõrge?
				\begin{enumerate}
					\item Jah, siis laetakse tagavara pesas olev tarkvara.
				\end{enumerate}
		\end{enumerate}
\end{enumerate}

\subsubsection{Alglaaduril ebaõnnestub vea logimine}
\begin{enumerate}
	\item Midagi juhtub ja alglaaduril ebaõnnestub vea logimine.
		\begin{enumerate}
			\item Vigade logi on täis?
				\begin{enumerate}
					\item Alglaadur ei kirjuta vanemaid sissekandeid üle.
				\end{enumerate}
		\end{enumerate}
	\item Alglaadur jätkab tööd ignoreeride probleemi.
\end{enumerate}

\subsubsection{Spetsiifilise tarkvara pildi alglaadimine}
\begin{enumerate}
	\item CDHS käivitab alglaaduri käsuga laadida tarkvara kindlast pesast.
	\item Alglaadur verifitseerib käsu.
	\item Logib õnnestumise.
	\item Tühjendab käskude nimekirja.
	\item Ja alglaeb tarkvara.
\end{enumerate}

\subsubsection{Alglaaduri kontrollsumma erinevus}
\begin{enumerate}
	\item Alglaadur arvutab enda kontrollsumma.
	\item Siis proovib seda võrrelda varem kuhugi salvestatuga.
		\begin{enumerate}
		\item Oletame, et need ei ole võrdsed.
		\end{enumerate}
	\item Viga logitakse.
	\item Alglaadur valib vaikimisi tarkvara pildi ja proovib seda alglaadida.
\end{enumerate}

\subsection{Muutused töö käigus}
todo: millised nõuded muutusid ja miks.

\section{Alglaadimine}
\label{sec:boot}
\subsection{Tavapärane alglaadimisprotseduur}
Kui mikrokontrolleril toide olemas on üritab see ennast tööle panna.
Esmalt lülitatakse sisse sisemine 8-MHz-ne ossillaator, mille signaali
neljandal tõusval frondil loetakse konfigureerimise viikude väärtused. Nende
väärtuste põhjal otsustatakse, millisest kohast alglaadida. Võimalikud
variandid on: põhi välkmälu, süsteemi mälu ja staatiline juhupöördlusega
mälu(SRAM).  Enim kasutatakse kahte esimest: põhi välkmälu seal oleva programmi
käivitamiseks ja süsteemi mälu, et põhimälu muuta. Tehases paigaldatakse
süsteemi mällu, mis on tegelikult lihtsalt üks kaitstud osa põhi välkmälu
lõpust, alglaadur, mille abil saab programmeerida ülejäänud välkmälu ehk oma
programmi mikrokontrollerile laadida.

Oletades, et programm on juba kiibi välkmälus olemas ja alglaadimist
alustatakse põhi välkmälust, vaatleme edasist protsessi. Välkmälu aadress on
tegelikult 0x800 0000, aga viikude oleku tõttu peegeldatakse see ka aadressile
0x0000 0000, kust protsessor oma tööd alustab.  Protsessor võtab aadressil
0x0000 0000 oleva väärtuse ja seab selle pinu ülemiseks väärtuseks. Seejärel
alustatakse instruktsioonide täitmist lähtestamise vektorist, mille
algusaadress on kirjas aadressil 0x0000 0004. \cite{f1rm}

Lähtestamise vektoril on tavaliselt assembleris kirjutatud protseduur, mis
kopeerib programmi andmete sektsiooni välkmälust SRAMi, täidab ülejäänud
programmi jaoks vajaliku ala SRAMist nullidega, kutsub välja C koodis kirjutatud
protseduuri, mis initsialiseerib süsteemi kella, ja siis annab juhtimise üle C
koodis kirjutatud \textit{main} protseduurile. Satelliidi peal ei kasutata
üldist kella seadmise koodi ja seega see samm jäetakse vahele ning kella
seadmine kutsutakse välja \textit{main}ist.

See, mida tarkvara edasi initisaliseerib, on juba tarkvara spetsiifiline.
Tõenäoliselt initsialiseeritakse mõned riistvaralised moodulid näiteks USART või
SPI ja hakatakse siis rakendusele vajalikku kontrolltsüklit täitma. Satelliidil
Estcube-1 kasutatakse nii CAMil kui ka CDHSil reaalaja operatsioonisüsteemi
FreeRTOS.

\subsection{Programmi alglaadimine koos alglaaduriga}
Alglaadur ise käitub alglaadimise seisukohalt nagu iga teinegi programm ja
laetakse täpselt samamoodi nagu eelmises alapeatükis kirjeldatud. See tähendab
seda, et alglaaduri katkestusvektorite tabel peab asuma välkmälu alguses, sest
sealt hakkab protsessor seda otsima. Kuna üks osa alglaadurist asub juba
välkmälu alguses, on ka teised osad sinna järele paigutatud, mis omakorda
tähendab, et tegelik põhiprogramm peab nüüd asuma kusagil mujal kui välkmälu
alguses ja sellega peab arvestama põhiprogrammi linkimisel.

Kui alglaadur on oma muud ülesanded juba täitnud, on tema viimaseks tööks
põhitarkvara käivitamine. Selleks käitub sarnaselt protsessoriga, kuid
kõigepealt on tal vaja teada, mis aadressil põhitarkvara katkestusvektorite
tabel asub. See aadress on aga eelnevalt kokkulepitud ja sissekodeeritud.

Enne põhitarkvara töölepanemist tuleks puhtaks teha pinu. Alglaaduri enda töö
ajal sinna salvestatud väärtusi pole põhiprogrammil kohe kuidagi vaja. Pinu
puhtaks tegemine tähendab lihtsalt pinu viida algväärtustamist, sest nii
hakatakse edaspidi pinus juba olevaid andmeid üle kirjutama ja kui programm on
korrektne, siis midagi sellist ei loeta, mida programm ise pole juba üle
kirjutanud. Algväärtustamiseks kasutatakse põhitarkvara katkestusvektorite
tabeli esimest elementi, mis näitas pinu ülemist aadressi.

Kuigi mikrokontrolleri käivitamise hetkel alustatakse tööd kindlast kohast, ei
pea terve katkestusvektorite tabel välkmälu alguses olema. Katkestustega tegeleb
eraldi riistvara moodul NVIC (\textit{Nested Vectored Interrupt Controller}).
Lisaks on sellega tihedalt seotud teine moodul SCB (\textit{System Control
Block}), kus asub seadistatav register VTOR (\textit{Vector Table Offset
Register}), mille väärtust kasutatakse katkestusvektorite tabeli aadressina.
\cite[ptk~4.4]{CM3pm} Vaikimisi on seal väärtus 0x0000 0000, mida kasutatakse alglaaduri
laadimiseks, kuid alglaadur seab selleks väärtuseks põhiprogrammi
katkestusvektorite tabeli aadressi. Kui seda ei seadistataks, siis kutsutaks
põhiprogrammi katkestuse ajal välja alglaaduri katkestusvektoreid, mis on
tegelikult implementeerimata, sest alglaadur ei kasuta katkestusi, ja nii ei
saaks põhitarkvara oma ülesandeid täita. Lisaks sellele on vaikimisi katkestuse
teenindamise rutiin lihtsalt lõputu tsükkel, seega jääks kontroller katkestusse
kinni ja halvatud ei oleks ainult põhitarkvara katkestuse teenindamine vaid kogu
põhitarkvara töö peatuks.

Kui pinu viit ja katkestusvektorite tabeli asukoht on ära seadistatud jääb üle
veel lugeda katkestusvektorite tabelist põhiprogrammi lähtestamise vektori
aadress ja mikrokontrolleri töö sinna edasi juhtida. Selleks tehakse C-koodis
funktsiooni viit, mis väärtustatakse lähtestamise vektori aadressiga ning
seejärel kutsutakse see välja.

Edasine toimub sarnane tegevus nagu tavapärase alglaadimise juures, kus
lähtestamise vektoril olev kood kopeerib välkmälus oleva põhiprogrammi andmete
sekstsiooni SRAMi, tähendab SRAMi initsialiseerimata andmete jaoks ja seejärel
kutsub välja põhitarkvara \textit{main} protseduuri.


\section{Komponendid}
Töö on jagatud kaheks Eclipse projektiks, millest üks on alglaadur ise ja teine on
abiteek, mille abil saab alglaadurile käske anda, käske lugeda ja alglaaduri
logi lugeda. Eclipse on kasutusel sellepärast, et ülejäänud satelliidi tarkvara jaoks
kasutati Eclipse'i. 

\subsection{Alglaadur}

\subsection{Alglaaduri abiteek}
Alglaaduri abiteek koosneb ühest päisefailist ja ühest C-failist, mis
implementeerib päises olevad funktsioonid. Abiteek on tehtud selleks, et
lihtsustada ülejäänud tarkvaral alglaaduriga suhtlemist. Kuna näiteks käskude
nimekirja lugemine on tegevus, mida võiks saada teha välimine tarkvara käskude
nimekirja kontrollimiseks ja alglaadur ise käskude täitmiseks, siis koodi
duplitseerimise asemel kasutab alglaadur ise ka seda abiteeki.

Abiteegis on funktsioonid käskude nimekirja lugemiseks ja muutmiseks. Kuna
käskude nimekiri asub välimises FRAMis, millele saab ligi üle \iic siini, siis
on abiteegil vaja funktsioone, et FRAMi lugeda ja kirjutada. Samas on teada, et
nii alglaaduris kui ka põhitarkvaras, mis mõlemad abiteeki kasutavad, on olemas
juba funktsioonid selle jaoks. Seega on mõistlik kasutada juba olemasolevaid
funktsioone ka abiteegis. Levinud viis on selleks kasutada funktsiooniviitasid,
mis kaasa antakse, kuid nendest loobuti ja defineeriti päises lihtsalt
funktsioonide prototüübid. Kasutades funktsiooniviitasid oleks vea korral
probleem tekkinud programmi töö käigus, aga käesoleva lahenduse korral tuleb
viga välja juba linkimise faasis.

\section{Töö käik}
Esimesed läbirääkimised projekti osas toimusid oktoobris, kuid praktiline pool
sai hoo sisse alles novembris. Esimese asjana nagu manussüsteemide
programmeerimisel ikka, sai tehtud programm, mis vilgutab indikaatortulukest.
Kui mikrokontrolleril juba tulukesed vilkuma said, oli järgmiseks alglaaduri
põhifunktsionaalsus - teise programmi alglaadimine. todo: jätkata seda kirjeldust
natuke.

\subsection{Suurimad probleemid}
\subsubsection{Viga päises}
Mikrokontrolleri riitvaraga suhtlemine käib läbi kontroll- ja staatusregistrite,
mis asuvad lihtsalt kusagil programmi aadressiruumis. Lihtsustamaks nendega
suhtlemist teevad mikrokontrolleri tootjad tavaliselt C päisfailid, kus on iga
mooduli jaoks defineeritud tema registrite aadressid. Nii ei pea igaüks eraldi
oma koodis neid aadresse meelde jätma, vaid kasutab olemasolevaid päisfaile. See
muudab ka kirjutatava koodi loetavamaks.

Töö autor kopeeris alglaaduri jaoks need registrite nimesid ja aadresse siduvad
päisfailid ühest STMicroelectronicsi näidisprojektist. Testides ja
implementeerides \iic suhtlust CAMi prototüübil, tekkis probleem, et asi
lihtsalt ei töödanud. Pärast mitmeid tunde vea otsimist leiti, et
sisend-väljund viigud ei ole õigesti seadistatud, et \iic moodul saaks neid
kasutada. Kui kõik teised veakohad olid välistatud, avastati vea tegelik põhjus.
Nimelt oli viga tootja poolt tehtud päises. Viikude seadmistamisega
riistvaramoodulile seotud registrile vahetult eelneva registri suurus oli päises
32 bitti, kuid manuaalis oli kirjas, et see on 16bitine register. See tähendas,
et vajalikust registrist kirjutati 16 biti võrra mööda. 
\subsubsection{\textit{Chip Write Enable}}
Kui \iic suhtlus CAMi prototüübil toimima saadi ja suhtlus FRAMiga toimus, siis
asuti seda sama tegema ka CDHSi plaadil. Riistvaraline \iic moodul ise oli küll
samasugune, aga sisend-väljund viikude seadistamine oli natuke erinev. Tundus
nagu asi töötaks, aga FRAMi kirjutades ja siis lugedes ei olnud tagasiloetavad
andmed samad, mis sinna kirjutati.

Tagantjärele oli vea põhjus suhteliselt ilmne, kuid sellegipoolest kulus palju
aega enne, kui veale jällile jõuti. Nimelt oli kasutataval FRAMi kiibil eraldi
jalg, mis pidi olemas kindlas asendis, et FRAMi kirjutamine töötaks. CAMi
plaadil oli see jalg jäädavalt õigesse asendis, aga CDHSi peal oli see viik
ühendatud mikrokontrolleri viigu külge ja nii pidi tarkvara selle viigu enne
kirjutamist FRAMi õigesse asendisse panema.

\subsubsection{\textit{SPI slave select}}
Kui selgus, et siiski on vaja CDHSi peal kasutada SPI siinil olevat FRAMi,
esines ka selle implementeerimisel üks rohkem silumiseks aega võtnud probleem.
Kuna töö autorile öeldi ainult alglaaduri tööks vajaminevate asjade kohta, siis
jäi SPI siinil olevate teiste seadmete \textit{slave select} viigud
seadistamata. Ossilosgraafiga SPI suhtlust vaadates leiti, et tagasitulevad
andmed on küll väga imelikud, kuid neis on mingi loogiline struktuur. Tuli
välja, et SPI siinil olev reaalajakell üritas samal ajal koos FRAMiga andmeid
tagastada. Probleemi lahendus oli jällegi lihtne: määrati kõigi SPI siinil
olevate seadmete valimise viigud mitteaktiivseks. Ja alglaaduri töö ajal muudeti
ainult FRAMiga suhtlemise ajaks FRAMile vastavat seadme valimise viigu väljundit.

\section{Mida tulevikus paremini teha?}
todo: kui aega ja jaksu, siis siia midagi kirjutada.
\section{Summary}
todo: write summary
\section{Kokkuvõte}
todo: kirjuta kokkuvõte

\label{viited}
\bibliographystyle{plain}
\bibliography{viited}

\pagebreak
\textbf{Lihtlitsents lõputöö reprodutseerimiseks ja lõputöö üldsusele
kättesaadavaks tegemiseks}\\

Mina Karl Tarbe (sünnikuupäev: 20.02.1991)
\begin{enumerate}
	\item
		annan Tartu Ülikoolile tasuta loa (lihtlitsentsi) enda loodud teose ``Alglaadur
		ESTCube-1 käsu- ja andmehaldussüsteemile ja kaameramoodulile'', mille juhendaja on
		Meelis Roos,
		\begin{enumerate}
			\item 
				reprodutseerimiseks säilitamise ja üldsusele kättesaadavaks
				tegemise eesmärgil, sealhulgas digitaalarhiivi DSpace-is
				lisamise eesmärgil kuni autoriõiguse kehtivuse tähtaja
				lõppemiseni;
			\item
				üldsusele kättesaadavaks tegemiseks Tartu Ülikooli
				veebikeskkonna kaudu, sealhulgas digitaalarhiivi DSpace'i kaudu
				kuni autoriõiguse kehtivuse tähtaja lõppemiseni.
		\end{enumerate}
	\item
		olen teadlik, et punktis 1 nimetatud õigused jäävad alles ka autorile.
	\item
		kinnitan, et lihtlitsentsi andmisega ei rikuta teiste isikute
		intellektuaalomandi ega isikuandmete kaitse seadusest tulenevaid õigusi.
\end{enumerate}

Tartus, \textbf{07.05.2013}


\end{document}
