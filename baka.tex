\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[estonian]{babel}
\usepackage{cite}
\usepackage[hidelinks]{hyperref}

\title{Alglaadur ESTCube-1 käsu- ja andmehaldussüsteemile ja kaameramoodulile}
\author{Karl Tarbe}


\newcommand{\iic}{I${}^2$C }

\begin{document}
\begin{titlepage}
\begin{center}
	{\large TARTU ÜLIKOOL\\
MATEMAATIKA-INFORMAATIKA TEADUSKOND\\
Arvutiteaduse instituut\\
Informaatika eriala}
\vskip4cm
{\large Karl Tarbe}\\[6mm]
{\huge Alglaadur ESTCube-1 käsu- ja andmehaldussüsteemile ja kaameramoodulile}\\[4mm]
{\large Bakalaureusetöö (6 EAP)}
\end{center}
\vspace{2cm}
\begin{flushright}
	\large
	Juhendaja: Meelis Roos, MSc
\end{flushright}
\vspace{2cm}
\begin{tabular}{l p{8cm} r}
	Autor: & \dotfill & "\dots" mai 2013\\
	Juhendaja: & \dotfill & "\dots" mai 2013\\[6mm]
	\multicolumn{2}{l}{Lubatud kaitsmisele}\\
	Professor: & \dotfill & "\dots" mai 2013\\
\end{tabular}
\vfill
\centerline{Tartu 2013}
\end{titlepage}
\setcounter{page}{2}
\tableofcontents

\section{Sissejuhatus}
Aasta 2008 suvel alustati tudengisatelliidi projektiga. Esialgu pidi tegemist
olema väga lihtsa satelliidiga, kus peal on võib-olla üks või kaks
mikrokontrollerit, kuid asjad nii ei läinud. Inseneridele meeldib ikka üle
töötada ja asju paremaks teha. Nii sai ka eesti esimesest satelliidist päris
keeruline süsteem, mis koosneb mitmetest moodulitest. Kuna tegemist on üpris
keerulise süsteemiga peab ka selle juhtimiseks kasutatav tarkvara keeruline
olema ja iga keerulise tarkvara puhul esineb tavaliselt vigu. Siinkohal muutubki
aktuaalseks alglaadur, mille abil saab tarkvara uuendada.

\subsection{Estcube-1}
\subsubsection{Missioon}
Aastal 2006 leiutati uudne viis, kuidas kasutada päikeselt tulevat laetud
osakeste voogu ehk päikesetuult liikumiseks. Selleks kasutatakse peenikesi
juhtmeid, mis pingestatakse päikesetuule suhtes. Sama laenguga osakesed tõukuvad
ja kokkuvõttes hakkab päikesetuul neid juhtmeid koos lennumasinaga edasi
tõukama. Analoogia põhjal tavalise tuulega kutsutakse seda juhtmete kimpu
elektriliseks päikesepurjeks. Uudne lähenemine on umbes 100 korda efektiivsem,
kui hetkel planeetidevahelisteks lendudeks sobivaimad ioonmootorid.
\cite{errpuri}

Estcube-1 missiooniks on esimest korda ajaloos katsetada elektrilist
päikesepurje kosmoses. Satelliidi pardal olev juhtmete kimp kaalub 0,2 grammi ja
on 20 meetri pikkune. Stardi ajal on juhtmed keritud kokku rulli peale, et
stardimõõtmetesse ära mahtuda. Maa orbiidil pannakse satelliit pöörlema ja
tsentrifugaaljõu toimel keritakse päikesepuri aeglaselt rullilt maha.
Elektriline mootor kerib rulli lahti ja tsentrifugaaljõu tõttu kaugeneb puri
satelliidist ühtlaselt.
\subsection{Käsu- ja andmehaldussüsteem - CDHS}
\textit{Command and Data Handling System} ehk käsu- ja andmehaldussüsteem on
kavandatud satelliidi peamiseks pardaarvutiks. Peamised arvutused, mis määravad
satelliidi positsiooni, toimuvad just CDHSis. CDHSi salvestatakse igasugu
erinevaid andmeid, mida sõltuvalt maapealt tulevatele käskudele ka tagastatakse.

Süsteem koosneb nii tarkvarast kui ka elektroonikast, mille peal tarkvara
jooksutatakse. Antud bakalauresetöö raames pole põhitarkvara detailid eriti
olulised, aga elektroonika on natuke oluline. Nimelt kuuluvad CDHSi juurde ka
mitmed mälud, kus hoitakse erinevaid andmeid. Nendest mäludest oluliseks on
Ferroelektrilised juhupöördusega mälud (FRAM), sest need on radiatsioonirikkas
keskkonnas mitu korda töökindlamad kui tavapärased välkmälud (FLASH). Täpsemalt
on mäludest juttu peatükis~\ref{sec:m2lud}.

Protsessorituumaks on ARM Cortex-M3, mis paikneb STMicroelectronics-i poolt
valmistatud mikrokontrolleris STM32F103, millest tuleb lähemalt juttu
peatükis~\ref{sec:mcu}. Üheks märkimisväärseks omaduseks CDHSi puhul on see, et
süsteemis on osaline riistvaraline dubleeritus: trükkplaadil on kaks identset
mikrokontrollerit. Esialgu jookseb neist üks, kuid kui tuvastatakse, et see
mikrokontroller enam ei tööta, lülitatakse ümber teisele mikrokontrollerile.
Selle vea tuvastamise ja ümberlülitamise eest vastutab toitesüsteem. Lülitatakse
ümber ka andmesiinid, et mikrokontrollerist väljajäävad seadmed oleksid korraga
ühenduses ainult ühe mikrokontrolleriga.

Toitesüsteemis on implementeeritud ka niiöelda väline valvekoer. Kui CDHSi
mikrokontroller aegajalt ühte viiku ei vilguta, siis toitesüsteem tõlgendab seda
sellena, et CDHS on määramata olekus, ja taaskäivitab CDHSi temalt ajutiselt
toite ära võtmise abil. Seda signaali, mida CDHS genereerima peab nimetatakse
südamelöögi signaaliks, sest nagu inimese puhulgi, kui seda signaali pole, siis
süsteem või inimene on surnud.

\subsection{Kaameramoodul - CAM}
Kaameramooduli ülesandeks on teha pilte kontrollimaks, kas päikesepurje
veljakerimine õnnestub nii nagu soovitud. Sekundaarne ülesanne on teha maast ja
ka eestist pilte, mida saaks kasutada teaduse populariseerimise eesmärgil.
Pilte saab teha VGA resolutsioonis ehk 640\(\times\)480 pikslit, mida on üldises
mõttes küll väga vähe, kuid loodetavasti piisavalt, et etteantud ülesandeid
täita.

Sarnaselt CDHSiga juhib mooduli tööd mikrokontroller, mille tootjaks on
STMicroelectronics. Mikrokontrolleriks on STM32F217, mis laias laastus ei erine
eriti CDHSi peal kasutatavast STM32F103st, kuid nendest erinevustest lähemalt
saab lugeda peatükist~\ref{sec:mcu}.

Teine sarnasus CDHSiga on see, et ka CAMil on mikrokontrollerist väljajäävad
mälud. Täpsemalt on alglaaduri jaoks oluline, et CAMil asub FRAM tüüpi mälu,
millega mikrokontroller saab suhelda üle \iic andmesiini.

Ka CAMi jaoks on toitesüsteemis eraldi signaal, kuhu CAM peab südamelööke
genereerima täpselt samamoodi, nagu seda teeb CDHS.

\subsection{Mälud}
\label{sec:m2lud}
Alglaadur puutub kokku kolme tüüpi mäludega.

\subsubsection{Juhupöördusega staatiline mälu - SRAM}
Lühend SRAM tuleb inglise keelest \textit{Static Random Access Memory}. Tegemist
on hävimäluga ehk seal olevad andmed kaovad, kui mälul ei ole voolu. Mälu asub
mikrokontrolleri sees ja seda kasutab programm tavapärase operatiivmäluna.
Kasutusel olevad mikrokontrollerid lubavad sealt ka instruktsiooni käivitada,
aga seda funktsionaalsust alglaaduris ei kasutata.

\subsubsection{Välkmälu - Flash}
Tegemist on enimlevinud tehnoloogiaga säilmälude hulgas. Antud juhul paikneb
seda tüüpi mälu mikrokontrolleri sees. Seal asub tarkvara, mida mikroprotsessor
asub käivitama. Antud mikrokontrollerite puhul on mälu juhupöördusega nii
kirjutamiseks, kui ka lugemiseks, aga kirjutamiseks peab mälu olema eelnevalt
kustutatud ehk siis mälus peab olema eelnevalt vastava pikkusega ühtedest
koosnev bitijada. CDHSi peal kasutatava STM32F103 mikrokontrolleril toimub
välkmällusse kirjutamine alati 16 biti kaupa. CAMil kasutataval STM32F217l saab
valida järgnevate pikkuste vahel: 64, 32, 16 või 8 bitti \cite{f2fpm}. See valik
sõltub ka olemasolevast toitepingest, kuid et STM32F103 peal valikut ei ole ja
alglaadur peab mõlema peal töötama, siis sarnasuse huvides on valitud STM32F217
korral samuti 16 bitine pikkus.

Välkmälu on jagatud mälulehtedeks, mis võivad olla kõik sama suurusega nagu
STM32F103l või ka erineva suurusega nagu STM32F217l. Välkmälust kustutamine
toimub antud mikrokontrollerite puhul toimub kas terve mälu või ühe mälelehe
kaupa. Kusjuures kuigi sisuliselt on tegemist sama asjaga nimetatakse STM32F103
puhul mälulehti mälulehtedeks (\textit{memofy page}), aga STM32F217
dokumentatsioonis on kasutusel termin mälusektor (\textit{memory sector}).
\cite{f1fpm,f2fpm}

\subsubsection{Ferroelektriline juhupöördusega mälu - FRAM}
FRAM on nagu välkmälugi säilmälu, kuhu jäävad andmed alles ka siis, kui seadmelt
toide ära võtta. Nii CDHSil kui ka CAMil jääb FRAM mikrokontrollerist väljapoole
ja sellega tuleb suhelda üle SPI või \iic andmesiini.

FRAMil on mitmeid eeliseid välkmälu ees:
\begin{itemize}
	\item lubatud ülekirjutamise tsükleid on rohkem,
	\item voolutarve on kordades väiksem,
	\item kiirus on kordades parem,
	\item mälu on juhupöördusega,
	\item mälu on radiatsioonikindlam.
\end{itemize}
Kuid FRAMil on ka kaks miinust: esiteks on andmetihedus suhteliselt väike ja teiseks
on tema hind kõrgem. Seda tüüpi mälu kasutatakse satelliidil, sest see on
radiatsioonikindlam. \cite{fram}

\subsection{Mikrokontrollerid STM32F103 ja STM32F217}
\label{sec:mcu}
Mikrokontrollerid STM32F103 ja STM32F217 on mõlemad STMicroelectronics-i tooted,
mida kasutatakse vastavalt CDHSil ja CAMil. Üldiselt kogu järgnev tekst siin
alapeatükis viitab mikrokontrollerite tehnilistele manuaalidele
\cite{f1rm,f2rm}. Esimene alamosa kirjeldab kontrollerite ühisosa ja teine
kirjeldab nende erinevusi. Alglaaduri tööks mittevajalikud osad jäävad
kirjeldamata.
\subsubsection{Sarnasused}
\label{sec:mcu:same}
Neis mõlemas on protsessorituumaks ARM arhitektuuriga Cortex-M3, mis on väga
tihedalt seotud katkestustekontrolleriga. Täpsemalt selle kohta saab lugeda
manuaalist \cite{CM3pm}.

Mikrokontroller erineb mikroprotsessorist just selle poolest, et lisaks
mikroprotsessorile on mikrokontrolleris olemas ka ülejäänud vajalik, et tööd
teha: operatiivmälu, mälu tarkvara masinkoodi jaoks ja mitmed moodulid välise
maailmaga või väliste seadmetega suhtlemiseks. Mõned moodulid, mida alglaadur
oma töös kasutab aga on õnneks kasutamise seisukohalt täpselt samasugused.

Üheks selliseks mooduliks on kontrollsumma arvutamise üksus (\textit{CRC
calculation unit}), mille abil saab efektiivselt arvutada 32 bitist
kontrollsummat(CRC-32). On mitmeid erinevaid standardeid, mille järgi CRC-32te
arvutada. Antud moodul kasutab Ethernet-is ja mujal kasutusel olevat polünoomi,
mille väärtus kuueteistkümnendsüsteemis on 0x4C11DB7. 

Kuna alglaadur peab suhtlema väliste mäludega üle \iic ja SPI andmesiinide on
oluline ka see, et mõlema jaoks on eraldi moodulid olemas. Ilma eraldiasuva
moodulita peaks raiskama protsessoriaega, et ükshaaval erinevaid sisend/väljund
viike juhtida, mis on küll võimalik, kuid ebaefektiivne, sest protsessor peab
ühe andmevahetuse kella takti jooksul täitma mitmeid instruktsioone ja seega
on andmevahetuse üldine kellasagedus kümneid kuni sadu kordi aeglasem, kui
protsessori kellasagedus.

Ja lõpetuseks võib öelda, et alglaadimise protseduur on mõlemal kontrolleril
samasugune ja see on kirjeldatud peatükis~\ref{sec:boot}.

\subsubsection{Erinevused}
Esimeseks alglaaduri seisukohalt väheoluliseks erinevuseks on see, et
maksimaalne lubatud töösagedus protsessorile on STM32F103 korral 72MHz ning
STM32F217 korral 120MHz. Alglaaduri seisukohalt pole see oluline, sest alglaadur
kasutab kogu oma töö vältel madala sagedusega sisemist kellasignaali.

Alglaaduri seisukohalt oluliseks erinevuseks on aga sisemise välkmälu erinev
ülesehitus. STM32F103l on välkmälu jagatud kaheks mälupangaks (\textit{memory
bank}), millele on juurdepääsuks erinevad registrid, aga STM32F217l on üks
mälupank. Lisaks sellele on esimese kontrolleri puhul kõik mälulehed sama
suurusega, kuid ühe mälupangaga kontrolleris on mälulehtede suurused
varieeruvad. \cite{f1fpm,f2fpm}

Lisaks sellele on erinev sisend/väljund viikude seadistamine. Erinev on nii
lihtsalt viikude seadistamine kui ka mingite konkreetsete viikude seadistamine
nii, et riistvaralised moodulid saaksid neid kasutada.

\section{Süsteemi nõuded}
Käesolevas peatükis on väljatoodud alglaadurile alguses paikapandud nõuded ja
kasutusjuhud. Nende kirjapanemisega tegeles peamiselt Indrek Sünter, kes arendab
tarkvara CDHSile. 
\subsection{Alglaaduri käsud}
\subsubsection{Käsk kindla tarkvara alglaadimiseks}
Vajalik, et vahetada kasutatavat tarkvara. Käsu abil saab valida millises pesas
olev tarkvara alglaetakse.

\subsubsection{Käsk tarkvara kopeerimiseks}
Vajalik, et saaks teostada tarkvara uuendamist, kui CDHS töötab. Käsu eesmärk on
kopeerida tarkvara ühest mäluseadmest teise. Enne kopeerimist tuleb
valideerida tarkvara pildi terviklikkus.

\subsection{Alglaaduri käskude nimekiri}
\subsubsection{Käskude lisamine nimekirja}
Vajalik tarkvara uuendamiseks, kui CDHS töötab. Eeldab, et CDHSi põhitarkvara
töötab.

\subsubsection{Vigade logimine}
Vajalik, et vigadest teada saada. Kui mõne alglaaduri käsu täitmine ebaõnnestub
tuleb see logida.

\subsubsection{Vaikimisi alglaadimine}
Enamasti on alglaaduri käskude nimekiri tühi ja selleks ajaks oleks vaja head
ohutut vaikimisi käitumist, mis alglaeks olemasoleva tarkvara.

\subsubsection{Õnnestumise logimine}
Kui midagi alglaaduri töös halvasti läheb, siis on vaja teada, mida alglaadur
edukalt juba ära tegi.

\subsubsection{Käskude nimekirja valideerimine}
Radiatsiooni või mingi muu nähtuse tõttu võib käskude nimekiri kahjustada saada.
Vigaste käskude täitmise vältimiseks tuleb käskude nimekirja terviklikkus üle
kontrollida.

\subsection{Alglaaduri töö}
\subsubsection{Välisest mälust lugemine}
Sisemises välkmälus pole piisavalt ruumi, et hoida piisavat arvu tagavara
tarkvara pilte. Seega peab alglaadur suutma väliste mäluseadmetega suhelda.

\subsubsection{Sisemisse välkmällu kirjutamine}
Mikrokontroller suudab koodi jooksutada ainult sisemisest välkmälust või
SRAMist, seega peab alglaadur suutma paigutada tarkvara sinna, kus seda saab
käivitada.

\subsubsection{Tarkvara kontrollsumma kontrollimine kopeerimisel}
Tarkvara võib välises mälus kahjustada saada, seega tuleb enne kopeerimist
kontrollida, kas kontrollsumma klapib, et tagada tarkvara pildi terviklikkus.

\subsubsection{Tarkvara kontrollsumma kontrollimine alglaadimisel}
Tarkvara võib sisemises välkmälus kahjustada saada ja vigast tarkvara ei tohiks
käima panna.

\subsubsection{Südamelöögi pakkumine}
Alglaadur peab genereerima südamelöögi signaali, et toitesüsteem ei püüaks
toitepinget ära võttes CDHSile taaskäivitust teha.

\subsubsection{Tarkvarapesa valimine kasutades CDHS\_FIRM viiku}
Vea korral peab olema toitesüsteemil võimalus valida teine CDHSi tarkvara pilt.
Selleks muudab toitesüsteem CDHS\_FIRM viigu väärtust.

\subsubsection{Kahe mikrokontrolleri toetamine}
Alglaadur peab töötama nii STM32F103l, mis on CDHSil, kui ka
STM32F217l, mis on CAMil.

\subsection{Kasutuslood}
Siin on esitatud esialgsed kasutuslood, mis on töö autorile ette anti.
\subsubsection{Tavapärane alglaadimine}
\label{sec:usecase:default}
\begin{enumerate}
\item Protsessor laeb alglaaduri
	\begin{enumerate}
	\item Kõik lisaseadmed ja riistvaramoodulid lülitatakse välja.
	\item Kõik viigud seatakse analoogsisendiks.
	\item Valvekoera taimer (\textit{Watchdog Timer}) seadistatakse.
	\item Lihtsad \iic FRAMi ajurid laetakse.
	\item Kontrollsumma moodul seadistatakse.
	\item Südamelöögi signaal seadistatakse.
	\item Alglaadur kontrollib iseenda kontrollsummat.
	\item Alglaadur võtab esimese käsu, valideerib ja täidab selle.
	\item CDHSi tarkvara alglaetakse.
	\item CDHSi tarkvara loeb alglaaduri logi ja kopeerib sealt tema jaoks
		huvitavad elemendid oma vigade logisse.
	\end{enumerate}
\end{enumerate}

\subsubsection{CDHSi tarkvara uuendamine}
\label{sec:usecase:upgrade}
\begin{enumerate}
	\item Uue tarkvara pilt hoiustatakse välises FRAMis ning CDHS
		taaskäivitatakse koos
		\begin{enumerate}
			\item käsuga alglaadurile, et kopeerida see mikrokontrolleri
				sisemisse välkmälusse.
		\end{enumerate}
	\item Alglaadur võtab esimese käsu ja täidab selle.
		\begin{enumerate}
			\item Käsuks on kopeerida tarkvara pilt välimisest FRAMi pesast \(X\)
				sisemisse välkmälu pessa \(Y\).
				\begin{enumerate}
					\item Arvutatakse pesas \(X\) oleva pildi kontrollsumma ja
						võrreldakse seda pesa \(X\) päises olevaga.
						\begin{enumerate}
							\item Kopeeritakse tarkvara pilt pesast \(X\) pesasse \(Y\).
							\item Kontrollitakse tarkvara pilti pesas \(Y\) ja
								vajadusel korratakse kopeerimist kuni kolm
								korda.
							\item Logitakse õnnestumine.
						\end{enumerate}
				\end{enumerate}
		\end{enumerate}
\end{enumerate}

\subsubsection{Välisest FRAMist lugemine ebaõnnestub}
\label{sec:usecase:framerror}
\begin{enumerate}
	\item Alglaadur käivitatakse koos käsuga kopeerida tarkvara pilt välisest
		FRAMist.
	\item Alglaadur üritab lugeda välisest FRAMist.
		\begin{enumerate}
		\item Oletame, et FRAM ei vasta, või \iic andmesiin on hõivatud.
		\end{enumerate}
	\item \iic viga logitakse.
	\item Käskude nimekiri tühjendatakse.
	\item Alglaadur alglaeb vaikimisi pesas oleva tarkvara.
\end{enumerate}

\subsubsection{Kontrollsumma erinevus tarkvara pildil}
\begin{enumerate}
	\item Alglaaduril küsitakse opereerida tarkvara pildiga (kas kopeerida või
		alglaadida).
	\item Alglaadur arvutab tarkvara pildi kontrollsumma.
	\item Alglaadur võrdleb seda tarkvara pildi päises oleva kontrollsummaga.
		\begin{enumerate}
			\item Oletame, et need ei ühti.
		\end{enumerate}
	\item Viga logitakse.
	\item Käskude nimekiri tühjendatakse.
	\item Alglaadur valib vaikimisi tarkvara pildi ja proovib seda alglaadida.
\end{enumerate}

\subsubsection{Käskude nimekirjas on tundmatu käsk}
\begin{enumerate}
	\item Alglaadur vaatab käskude nimekirja.
		\begin{enumerate}
			\item Ja see ei ole tühi.
		\end{enumerate}
	\item Alglaadur võtab esimese käsu nimekirjast.
	\item Proovib seda verifitseerida, kuid ebaõnnestub.
	\item Alglaadur logib vea.
	\item Käskude nimekiri tühjendatakse.
	\item Alglaadur valib vaikimisi tarkvara pildi ja proovib seda alglaadida.
\end{enumerate}

\subsubsection{Soovitud tarkvara pilt valitakse FIRMW viigu abil}
\label{sec:usecase:fwselect}
\begin{enumerate}
	\item Alglaadur vaatab käskude nimekirja.
	\item Käskude nimekiri on tühi.
	\item Alglaadur vaatab FIRMW viiku.
		\begin{enumerate}
			\item See on madal?
				\begin{enumerate}
					\item Jah, siis laetakse vaikimisi pesas olev tarkvara.
				\end{enumerate}
			\item See on kõrge?
				\begin{enumerate}
					\item Jah, siis laetakse tagavara pesas olev tarkvara.
				\end{enumerate}
		\end{enumerate}
\end{enumerate}

\subsubsection{Alglaaduril ebaõnnestub vea logimine}
\begin{enumerate}
	\item Midagi juhtub ja alglaaduril ebaõnnestub vea logimine.
		\begin{enumerate}
			\item Vigade logi on täis?
				\begin{enumerate}
					\item Alglaadur ei kirjuta vanemaid sissekandeid üle.
				\end{enumerate}
		\end{enumerate}
	\item Alglaadur jätkab tööd ignoreerides probleemi.
\end{enumerate}

\subsubsection{Spetsiifilise tarkvara pildi alglaadimine}
\begin{enumerate}
	\item CDHS käivitab alglaaduri käsuga laadida tarkvara kindlast pesast.
	\item Alglaadur verifitseerib käsu.
	\item Logib õnnestumise.
	\item Tühjendab käskude nimekirja.
	\item Ja alglaeb tarkvara.
\end{enumerate}

\subsubsection{Alglaaduri kontrollsumma erinevus}
\begin{enumerate}
	\item Alglaadur arvutab enda kontrollsumma.
	\item Siis proovib seda võrrelda varem kuhugi salvestatuga.
		\begin{enumerate}
		\item Oletame, et need ei ole võrdsed.
		\end{enumerate}
	\item Viga logitakse.
	\item Alglaadur valib vaikimisi tarkvara pildi ja proovib seda alglaadida.
\end{enumerate}

\subsection{Muutused töö käigus}
Nagu peaaegu igale tarkvaraprojektile kohaselt, muutusid ka selle projekti
käigus nõuded. Aga seda peamiselt seetõttu, et esialgsete nõuete koostamisel ei
oldud teadlikult väga põhjalik ja esialgsed nõuded jätsid päris mitmed
detailid lahtiseks. Samuti on vasturääkivusi esitatud kasutuslugudes.

Kokkuvõtvalt sündisid konkreetsed tehnilised lahendused ikkagi töö käigus. Antud
nõuded ja kasutuslood olid küll suuna näitajateks, kuid neid ei võetud rangete
reeglitena, sest nende tegelik eesmärk oli lihtsalt midagi kirja panna, et
hakkaks moodustuma tervikpilt.

\subsubsection{Töö käigus tekkinud täpsustused}
Käskude nimekirja hoidmiseks valiti väline FRAM, sest see tundus kõige
turvalisem, sest ta on radiatsioonikindlam kui välkmälu ja kui peaks juhtuma, et
välise FRAMiga ei saa suhelda, siis nagunii pole alglaaduril võimalik tarkvara
kopeerida ning tarkvarapildi valimiseks saab kasutada ka toitesüsteemi, mis
muudab FIRMW viigule mineva signaali väärtust.

Samuti otsutati, et ka kopeerimine toimub just FRAMist sisemisse välkmälusse,
sest nii on alglaaduri keerukus väiksem, sest pole vaja eraldi suhtlust välise
välkmäluge, mis oli alternatiivne koht tarkvara piltide hoiustamiseks. 

Algselt leiti ka veel seda, et nii CAMil kui ka CDHSil on \iic siinil olev FRAM.
See tähendas, et oli vaja implementeerida ainult \iic suhtlus. Hiljem aga tehti
avastus, et CDHSil \iic andmesiinil olev FRAM on liiga väike, et seal tarkvara
pilte hoida. Seetõttu tuli implementeerida ka SPI siinil suhtlus FRAMiga, sest
CDHSi peal oli SPI siinil piisava suurusega FRAM. Teisest küljest CAMil ei ole
SPI siinil asuvat FRAMi ja seega CAMil kasutatakse \iic siinil olevat FRAMi.

\subsubsection{Kasutuslugude muutused}
Kasutusloos~,,\ref{sec:usecase:default}~\nameref{sec:usecase:default}'' pole vaja
teha kahte esimest tegevust, sest pärast mikrokontrolleri resetti on niigi kõik
lisaseadmed väljalülitatud ja enamik sisend/väljund viikudest on seadistatud
analoogsisendiks\cite{f1rm,f2rm}. Lisaks sellele leiti töö käigus, et sisemist
valvekoera taimerit ei peaks kasutatama, sest kui CDHSi tarkvara kokku jookseb,
teeb valvekoer mikrokontrollerile taaskäivituse, siis jookseb tarkvara uuesti
kokku ja asi jääb tsüklisse. Kui nüüd selle tsükli käigus ka südamelöögi
signaali genereeritakse, siis ei saaks toitesüsteem probleemist teada ja ei
oskaks ümber lülitada teisele tarkvara pesale või CDHSi puhul teisele
mikrokontrollerile. Samuti on ka neljas punkt natuke vale, sest CDHSil saab
FRAMile ligi \iic asemel üle SPI andmesiini.

Kasutusloos~,,\ref{sec:usecase:upgrade}~\nameref{sec:usecase:upgrade}'' ei ole vaja
Välimises FRAMis kindlat pesa määrata, vaid selle asemel kasutatakse otseselt
mäluaadressi, millelt tarkvara pilt leitakse. 

Kasutuslugu~,,\ref{sec:usecase:framerror}~\nameref{sec:usecase:framerror}''
tuleb ka muuta, sest FRAM ei pruugi alati olla \iic siinil ning enne
kopeerimise käsku tuleb FRAMist lugeda käskude nimekiri. Samuti käskude
nimekirja kustutamiseks on vaja FRAMi kirjutada.

Kasutusloo~,,\ref{sec:usecase:fwselect}~\nameref{sec:usecase:fwselect}'' puhul
tehtud muudatus on selline, et käskude nimekiri ei pea olema tühi. Lihtsalt iga
kord, kui on juttu vaikimisi pesas oleva tarkvara alglaadimisest, siis valitakse
pesa vastavalt selle viigu väärtusele. Ja koodis on tagavara pesa asemel leebem
nimetus: sekundaarne pesa.

\section{Alglaadimine}
\label{sec:boot}
\subsection{Tavapärane alglaadimisprotseduur}
\label{sec:boot:tava}
Kui mikrokontrolleril toide olemas on üritab see ennast tööle panna.
Esmalt lülitatakse sisse sisemine 8-MHz-ne ossillaator, mille signaali
neljandal tõusval frondil loetakse konfigureerimise viikude väärtused. Nende
väärtuste põhjal otsustatakse, millisest kohast alglaadida. Võimalikud
variandid on: põhi välkmälu, süsteemi mälu ja staatiline juhupöördlusega
mälu(SRAM).  Enim kasutatakse kahte esimest: põhi välkmälu seal oleva programmi
käivitamiseks ja süsteemi mälu, et põhimälu muuta. Tehases paigaldatakse
süsteemi mällu, mis on tegelikult lihtsalt üks kaitstud osa põhi välkmälu
lõpust, alglaadur, mille abil saab programmeerida ülejäänud välkmälu ehk oma
programmi mikrokontrollerile laadida.

Oletades, et programm on juba kiibi välkmälus olemas ja alglaadimist
alustatakse põhi välkmälust, vaatleme edasist protsessi. Välkmälu aadress on
tegelikult 0x800 0000, aga viikude oleku tõttu peegeldatakse see ka aadressile
0x0000 0000, kust protsessor oma tööd alustab.  Protsessor võtab aadressil
0x0000 0000 oleva väärtuse ja seab selle pinu ülemiseks väärtuseks. Seejärel
alustatakse instruktsioonide täitmist lähtestamise vektorist, mille
algusaadress on kirjas aadressil 0x0000 0004. \cite{f1rm}

Lähtestamise vektoril on tavaliselt assembleris kirjutatud protseduur, mis
kopeerib programmi andmete sektsiooni välkmälust SRAMi, täidab ülejäänud
programmi jaoks vajaliku ala SRAMist nullidega, kutsub välja C koodis kirjutatud
protseduuri, mis initsialiseerib süsteemi kella, ja siis annab juhtimise üle C
koodis kirjutatud \textit{main} protseduurile. Satelliidi peal ei kasutata
üldist kella seadmise koodi ja seega see samm jäetakse vahele ning kella
seadmine kutsutakse välja \textit{main}ist.

See, mida tarkvara edasi initsialiseerib, on juba tarkvara spetsiifiline.
Tõenäoliselt initsialiseeritakse mõned riistvaralised moodulid näiteks USART või
SPI ja hakatakse siis rakendusele vajalikku kontrolltsüklit täitma. Satelliidil
Estcube-1 kasutatakse nii CAMil kui ka CDHSil reaalaja operatsioonisüsteemi
FreeRTOS.

\subsection{Programmi alglaadimine koos alglaaduriga}
Alglaadur ise käitub alglaadimise seisukohalt nagu iga teinegi programm ja
laetakse täpselt samamoodi nagu eelmises alapeatükis kirjeldatud. See tähendab
seda, et alglaaduri katkestusvektorite tabel peab asuma välkmälu alguses, sest
sealt hakkab protsessor seda otsima. Kuna üks osa alglaadurist asub juba
välkmälu alguses, on ka teised osad sinna järele paigutatud, mis omakorda
tähendab, et tegelik põhiprogramm peab nüüd asuma kusagil mujal kui välkmälu
alguses ja sellega peab arvestama põhiprogrammi linkimisel.

Kui alglaadur on oma muud ülesanded juba täitnud, on tema viimaseks tööks
põhitarkvara käivitamine. Selleks käitub sarnaselt protsessoriga, kuid
kõigepealt on tal vaja teada, mis aadressil põhitarkvara katkestusvektorite
tabel asub. See aadress on aga eelnevalt kokkulepitud ja sissekodeeritud.

Enne põhitarkvara töölepanemist tuleks puhtaks teha pinu. Alglaaduri enda töö
ajal sinna salvestatud väärtusi pole põhiprogrammil kohe kuidagi vaja. Pinu
puhtaks tegemine tähendab lihtsalt pinu viida algväärtustamist, sest nii
hakatakse edaspidi pinus juba olevaid andmeid üle kirjutama ja kui programm on
korrektne, siis midagi sellist ei loeta, mida programm ise pole juba üle
kirjutanud. Algväärtustamiseks kasutatakse põhitarkvara katkestusvektorite
tabeli esimest elementi, mis näitas pinu ülemist aadressi.

Kuigi mikrokontrolleri käivitamise hetkel alustatakse tööd kindlast kohast, ei
pea terve katkestusvektorite tabel välkmälu alguses olema. Katkestustega tegeleb
eraldi riistvara moodul NVIC (\textit{Nested Vectored Interrupt Controller}).
Lisaks on sellega tihedalt seotud teine moodul SCB (\textit{System Control
Block}), kus asub seadistatav register VTOR (\textit{Vector Table Offset
Register}), mille väärtust kasutatakse katkestusvektorite tabeli aadressina.
\cite[ptk~4.4]{CM3pm} Vaikimisi on seal väärtus 0x0000 0000, mida kasutatakse alglaaduri
laadimiseks, kuid alglaadur seab selleks väärtuseks põhiprogrammi
katkestusvektorite tabeli aadressi. Kui seda ei seadistataks, siis kutsutaks
põhiprogrammi katkestuse ajal välja alglaaduri katkestusvektoreid, mis on
tegelikult implementeerimata, sest alglaadur ei kasuta katkestusi, ja nii ei
saaks põhitarkvara oma ülesandeid täita. Lisaks sellele on vaikimisi katkestuse
teenindamise rutiin lihtsalt lõputu tsükkel, seega jääks kontroller katkestusse
kinni ja halvatud ei oleks ainult põhitarkvara katkestuse teenindamine vaid kogu
põhitarkvara töö peatuks.

Kui pinu viit ja katkestusvektorite tabeli asukoht on ära seadistatud jääb üle
veel lugeda katkestusvektorite tabelist põhiprogrammi lähtestamise vektori
aadress ja mikrokontrolleri töö sinna edasi juhtida. Selleks tehakse C-koodis
funktsiooni viit, mis väärtustatakse lähtestamise vektori aadressiga ning
seejärel kutsutakse see välja.

Edasine toimub sarnane tegevus nagu tavapärase alglaadimise juures, kus
lähtestamise vektoril olev kood kopeerib välkmälus oleva põhiprogrammi andmete
sekstsiooni SRAMi, tähendab SRAMi initsialiseerimata andmete jaoks ja seejärel
kutsub välja põhitarkvara \textit{main} protseduuri.


\subsection{Programmi ettevalmistamine}
\label{sec:boot:prep}
Selleks, et põhitarkvara saaks kasutada alglaaduriga, tuleb eelnevalt programm
niimoodi linkida, et arvestatakse sellega, millisele mäluaadressile tarkvara
hiljem pannakse. Üks koht, kus kindlalt on absoluutsed mälu aadressid on see
sama katkestusvektorite tabel. Kui programm saab niimoodi tehtud, et ta arvab,
et näiteks taimeri katkestuse käsitlemise funktsioon on välkmälu alguses
aadressil 0x800 09F0, ja programm kopeeritakse alglaaduri poolt ise kuhugi teise
kohta kui välkmälu algus (0x800 0000), siis taimerikatkestuse korral hakatakse
täitma käskusi aadressilt 0x800 09F0, kus tõenäoliselt paikneb alglaadur ise.

Võrdluseks võib tuua näiteks Linuxi, kus ei ole vaja programme uuesti linkida,
et neid erinevatel mäluaadressidel tööle panna, aga seda seepärast, et iga
programmi jaoks tekitatakse virtuaalne mäluruum, kus programm on alati kindlal
aadressil.

\section{Muud implementatsioonidetailid}
\subsection{Alglaaduri kontrollsumma kontrollimine}
Alglaaduri enda kontrollsumma arvutamiseks kasutatakse riistvaramoodulit,
millest oli juttu peatükis~\ref{sec:mcu:same}.

Kui aga kontrollsumma on arvutatud tuleb seda millegagi võrrelda. Selleks on
linkija skriptis alglaaduri lõppu lisatud üks 4 baidi piirile joondatud
32-bitine muutuja. Muutuja on 4 baidi piirile joondatud, sest kontrollsumma
arvutamise moodul arvutab just 4 baidi ehk 32 biti kaupa. Selle muutuja
algväärtustamisel on tehtud lisaeeldus, et alglaadur ei saa kannatada enne
esimest töölepanemist. Seda eeldust on vaja, sest linkija paneb selle väärtuseks
lihtsalt 0xFFFF FFFF ja esimesel korral, kui alglaadur oma kontrollsumma
arvutab, programmeeritakse välkmälus see väärtus üle tegeliku kontrollsummaga.
Kusjuures esialgne väärtus 0xFFFF FFFFF ei ole niisama valitud. See väärtus on
sellepärast, et selline on välkmälu kustutatud asendis, ja nii on võimalik see
üle programmeerida ilma tervet sektorit eelnevalt kustutamata.

\subsection{Tarkvara pildi päis}
Tarkvara pilti võib vaadelda, kui lihtsalt ühte suurt kogu andmeid, mille
alguses on katkestusvektorite tabel. Alglaaduri seisukohast oleks vajalik, et
oleks teada ka nende andmete pikkus ja kontrollsumma. Selleks lisatakse
tarkvarapildi ette nii FRAMis kui ka välkmälus pisike päis, kus on kolm 32
bitist välja: suurus, versioon ja kontrollsumma. Versioonivälja alglaadur ise
kunagi ei puutu, aga põhitarkvara ise võib sellest kasu saada, et
versiooninumber on ka olemas.

Selle päise lisamine aga tekitas ühe lisaprobleemi. Nimelt on välkmälus valitud
tarkvarapesad selliselt, et need algaksid välkmälu lehtede piirilt, et neid
oleks mugav kustutada. Need on suhteliselt ümmargused aadressid, kus ümmargune
tähendab seda, et aadressi madalamad bitid on nullid. Enne selle päise lisamist
töötas põhitarkvara normaalselt, kuid pärast päise lisamist esinesid probleemid
põhitarkvara töös. Põhjuseks oli katkestusvektorite tabeline nihkumine päise
võrra edasi, aga katkestusvektorite tabel peab olema ka mõnevõrra ümmargusel
aadressil: 9 madalamat bitti peavad olema nullid\cite{cm3pm}.

Kompenseerimiseks lisati lihtsalt päise ja ülejäänud tarkvarapildi vahele 500
baiti polstrit, mis nihutas katkestusvektorite tabeli jälle piisavalt
ümmargusele aadressile. See lahendus küll töötab, kuid raiskab ära 500 baiti.
Alternatiivina oleks saanud panna selle päise pärast katkestusvektorite tabelit,
sest katesktusvektorite tabel on fikseeritud pikkusega, kuid see oleks rohkem
tööd võtnud ja samuti oleks siis pidanud eraldi arvutama kontrollsumma
katkestusvektorite tabelist ja ülejäänud osast, mis jääks teisele poole päist.

Tarkvarapilt koos päise ja polsterdusega on ühesugune nii FRAMis kui ka
välkmälus, kuigi FRAMis pole seda polsterdust vaja. Tarkvara kontrollsumma
arvutamisel ei arvutata sisse päist ega polsterdust. Samas saab kasutada seda
polsterdust, et seal veel mingeid metaandmeid tarkvara pildi kohta hoida, sest ka
see polsterdust kopeeritakse alglaaduri poolt kohusetundlikult FRAMist
välkmällu.

\subsection{Käskude nimekiri}
Käskude nimekiri asub FRAMis. Kasutades alglaaduri abiteeki saab sinna kirjutada
maksimaalselt 3 käsku ja valida on kahe käsutüübi vahel: kopeerimine või
alglaadimine. Iga käsk koos oma parameetritega kirjutatakse FRAMi kahekordselt,
kusjuures teine kord on kõik bitid inverteeritud. 

Et vältida vanade käskude nimekirja sattumist, kirjutatakse iga käsu lõppu veel
kaks baiti, mille väärtuseks on 0xFF. See tagab selle, et kui enne oli kolm
käsku nimekirjas ja siis kirjutati uus käsk, kirjutavad need kaks lisabaiti üle
vana käsu alguse. Ja seega alglaadur ei loe kaugemale ühest käsust.

Käskude nimekirja tühendamine tähendab lihtsalt maksimaalse suurusega alale
0xFFide kirjutamist. Kusjuures käskude nimekirja lugedes ei eristata, kas
käskude nimekiri oli tühi või lihtsalt esimene bait nimekirjas oli vale.

Ühe puudusena võib välja tuua selle, et käskude nimekirja lugedes ei
kontrollita, kas on ainult kolm käsku. Ja nii saab FRAMi kirjutada ka sellise
käskude nimekirja, kus on näiteks sadu kopeerimiskäske, aga see ei ole probleem,
sest käskude nimekirja ei loeta korraga mälusse vaid täidetakse käskhaaval.


\subsection{Südamelöögi signaali genereerimine}
Südemelöögi signaali võiks genereerida kasutades selleks riistvaralist taimerit,
kuid see oleks vale, sest tarkvara võib kokku joosta, kuid taimer genereerib
signaali edasi. Seega on õigem tarkvarast manuaalselt seda signaali genereerida.
Pealegi see signaal ei pea olema midagi erilist. Lihtsalt ühe väljundviigu
väärtust tuleb muuta. Ning pole oluline, kui seda tehakse liiga tihti.

Viigu väärtust muudetakse vahetult enne põhitarkvara alglaadimist ja kahes
funktsioonis, mida kasutatakse, et oodata mingite operatsioonide lõppemist.
Nendest esimene on välkmälu operatsioonide jaoks ja teine \iic FRAMi jaoks. Siit
aga tuleb välja üks probleem, mis on kirjas peatükis~\ref{sec:prob:beat}. 

\section{Komponendid}
Töö on jagatud kaheks Eclipse projektiks, millest üks on alglaadur ise ja teine on
abiteek, mille abil saab alglaadurile käske anda, käske lugeda ja alglaaduri
logi lugeda. Eclipse on kasutusel sellepärast, et ülejäänud satelliidi tarkvara jaoks
kasutati Eclipse'i. 

\subsection{Alglaadur}
Alglaaduri projekt koosneb mitmetest failidest, mille hulgas on 9 C-faili, 4
päisefaili, 2 assembleri faili ja 2 linkimise skripti. Kuna alglaadur peab töötama kahel erineval
platvormil, siis on platvormispetsiifilised kohad koodis kaitstud eeltöötluse
makrodega (\textit{preproccesor macros}). Eeltöötluse jaoks defineeritakse
sümbolid vastavalt Eclipse projektis olevale ehitamise seadistusele
(\textit{build configuration}). See tähendab, et kompilleerides alglaadurit
näiteks CDHSi jaoks, siis need osad koodist, mis on mõeldud ainult CAMile,
jäävad kompillaatoril nägemata, sest eeltöötluse käigus võetakse need välja.

\subsubsection{Assemblery failid: \textbf{startup\_stm32fxxxx.S}}
Failid \textbf{startup\_stm32f10x\_xl.S} ja \textbf{startup\_stm32f2xx.S} on
tegelikult peaaegu täpselt samasugused. Neid on kaks tükki, sest alglaadur peab
töötama kahel erineval mikrokontrolleril. Neis failides on kirjas
katkestusvektorite tabel, mis on kasutataval mikrokontrolleritel erinev. Lisaks
sellele on neis failides see põhiline andmete SRAMi kopeerimine, SRAMi nullide
kirjutamine ja C-koodis oleva \textit{main}i väljakutsumine, millest oli juttu
peatükis~\ref{sec:boot:tava}.

\subsubsection{Süsteemi päised: \textbf{stm32fxxx.h}}
Päised \textbf{stm32f10x.h} ja \textbf{stm32f2xx.h} on mikrokontrolleritele
STM32F103 ja STM32F217 vastavad abifailid, milles on defineeritud eeltöötluse
makrod ja struktuurid, mis teevad riistvaramoodulite registrite kasutamise
oluliselt lihtsamaks. Need failid on üldiselt saadaval mikrokontrolleri tootja
käest.

\subsubsection{Cortex-M3 päis: \textbf{core\_cm3.h}}
Selles päises on defineeritud protsessorituumaga seotud registritele
juurdepääsemist abistavad makrod ja struktuurid. Lisaks selle on seal
prototüübid funktsioonidele, mis annavad C-koodist juurdepääsu spetsiaalsetele
instruktsioonidele, mida kompillaator omapead ei kasuta. Päisega käib koos
implementatsioonifail \textbf{core\_cm3.c}, kus on antud siis implementatsioonid
nendele spetsiaalsetele intruktsioonidele kasutades selleks C-faili kirjutatavat
assemblerit. Nii päis kui ka implementatsioon on saadaval Cortex-M3
protsessorituuma disainijalt ARM Holdings-ilt.

\subsubsection{Peamine päisfail - \textbf{bootloader.h}}
Esimese asjana kaasab see päis endaga vastavalt eeltöötluse muutujatele õige
süsteemi päise. Kuna peaaegu kõik teised C-failid kaasavad selle faili saavad
nad nii ka ligipääsu õigetele süsteemi päisetele, mille abil
riistvaramoodulitega suhelda. Lisaks sellele on antud failis kogu bootloaderis
kasutatavate funktsioonide prototüübid. Tavalised tehakse küll nii, et ühe
tarkvaramooduli kohta on üks päisfail ja üks implementatsioonifail, aga nii
oleks tekkinud palju lühikesi päisfaile, mis teevad koodi lugemise asjatult
raskemaks.

\subsubsection{Põhifunktsionaalsus - \textbf{bootloader.c}}
Selle failis on implementeeritud alglaaduri põhifunktsionaalsus. Seal on
protseduurid kindlal aadressil oleva tarkvara alglaadimiseks, tarkvara
kopeerimise käsu ja kindlas pesas oleva tarkvara alglaadimise käsu täitmiseks.

\subsubsection{Sisemise välkmäluga opereerimine - \textbf{flash.c}}
Failis on implementeeritud välkmälu kustutamine ja programmeerimine.
Lugemist pole vaja, sest välkmälu asub mikrokontrolleri aadressiruumis ja sealt
lugemine tähendab lihtsalt mingilt aadressilt lugemist. Implementatsioon on
selline, mis abstrakteerib ära mikrokontrollerite erinevused.

\subsubsection{\texorpdfstring{\iic}{I2C} FRAMiga suhtlemine - \textbf{fram.c}}
Fail implementeerib \iic suhtluse välise FRAMiga. Antud fail töötas nii CDHSil
kui ka CAMil, kuid hiljem selgus, et CDHSi peal peab siiski kasutama SPI siinil
olevat FRAMi. Sellest ajast on ka faili nimi lihtsalt viide mälu tüübile, kuna
siis pidi olema kasutusel ainult \iic siinil olev FRAM.

Fail on kasutusel ainult CAMil.

\subsubsection{SPI FRAMiga suhtlemine - \textbf{fram\_spi.c}}
Failis on implementeeritud samad funktsioonid FRAMiga suhtlemiseks, kuid seda
üle SPI andmesiini. Kasutatud on paari kavalat võtet, et koodi mahtu vähendada.

Fail on kasutusel ainult CDHSil.

\subsubsection{Sisend/väljund viikude seadmine - \textbf{gpio.c}}
Antud fail lubab lisaseadmetele tööks vajaliku kellasignaali, seadistab
sisend/väljund viigud ja määrab need vajadusel riistvaramoodulitele. Samuti on
seal funktsioonid tarkvara valimise viigu lugemiseks ja südamelöögi
tekitamiseks. Antud failis on vastavad funktsioonid mõlemale mikrokontrollerile,
kuid need erinevused on ära abstrakteeritud.

\subsubsection{Alglaaduri logimine - \textbf{logging.c}}
Alglaaduri logi salvestatakse ühte välkmälu lehte. Igal alglaaduri käivitamisel
leitakse kahendotsinguga üles seal lehes koht, kuhu logi kirjutamine pooleli jäi
ja jätkatakse sealt logi täitmist. Kui juhtub, et käivitamise hetkel on logi
peaaegu täis, siis võetakse viimased 10 logi elementi, kopeeritakse need SRAMi,
kustutatakse mäluleht välkmälus ära, ja siis kirjutatakse need 10 logi elementi
logi algusesse. Samuti on hoolitsetud selle eest, et kui isegi peaks kuidagi töö
käigus logisse rohkem kirjutatama, kui logis ruumi on, siis jäetakse ikkagi logi
alast välkmälus väljapoole kirjutamata.

\subsubsection{Alguspunkt - \textbf{main.c}}
Siin failis asub \textit{main} protseduur, mis initsialiseerib kõigepealt
sisend/väljund viigud, logi ja välise FRAMiga suhtlemiseks vajaliku SPI või \iic
mooduli. Seejärel kontrollib ta alglaaduri enda kontrollsummat. Pärast mida
täidab ta käskude nimekirjas olevad käsud ja lõpetuseks teeb vaikimisi
alglaadimise.

\subsubsection{Testid - \textbf{tests.c}}
Siin failis on mõned funktsioonid, mida kasutati testimisel, kuid alglaaduris
neid tegelikult vaja ei ole. Siin on kood FRAMist kirjutamise ja lugemise
testimiseks, logisse kirjutamiseks ning käskude nimekirja testkäskude
panemiseks.

\subsubsection{Linkija skriptid - \textbf{stm32\_fx\_flash.ld}}
Tegemist on kahe failiga, mida vastavalt platvormile kasutatakse alglaaduri
linkimiseks. Failides on defineeritud mäluregioonid, mis vastavad alglaaduri
logile ja põhitarkvara pesadele, koos muutujatega, et alglaadurist neid regioone
kasutada. Ühe pisikese lisana on ka pärast alglaaduri koodi-, andmete- ja
nullidesektsiooni ka koht alglaaduri enda kontrollsumma jaoks.

\subsection{Alglaaduri abiteek}
Alglaaduri abiteek koosneb ühest päisefailist ja ühest C-failist, mis
implementeerib päises olevad funktsioonid. Abiteek on tehtud selleks, et
lihtsustada ülejäänud tarkvaral alglaaduriga suhtlemist. Kuna näiteks käskude
nimekirja lugemine on tegevus, mida võiks saada teha välimine tarkvara käskude
nimekirja kontrollimiseks ja alglaadur ise käskude täitmiseks, siis koodi
duplitseerimise asemel kasutab alglaadur ise ka seda abiteeki.

Abiteegis on funktsioonid käskude nimekirja lugemiseks ja muutmiseks. Kuna
käskude nimekiri asub välimises FRAMis, millele saab ligi üle \iic siini, siis
on abiteegil vaja funktsioone, et FRAMi lugeda ja kirjutada. Samas on teada, et
nii alglaaduris kui ka põhitarkvaras, mis mõlemad abiteeki kasutavad, on olemas
juba funktsioonid selle jaoks. Seega on mõistlik kasutada juba olemasolevaid
funktsioone ka abiteegis. Levinud viis on selleks kasutada funktsiooniviitasid,
mis kaasa antakse, kuid nendest loobuti ja defineeriti päises lihtsalt
funktsioonide prototüübid. Kasutades funktsiooniviitasid oleks vea korral
probleem tekkinud programmi töö käigus, aga käesoleva lahenduse korral tuleb
viga välja juba linkimise faasis: kui prototüüpidele vastavate funktsioonide
implementatsiooni ei leita, siis annab linkija veateate.

\section{Töö käik}
Esimesed läbirääkimised projekti osas toimusid oktoobris, kuid praktiline pool
sai hoo sisse alles novembris. Esimese asjana nagu manussüsteemide
programmeerimisel ikka, sai tehtud programm, mis vilgutab indikaatortulukest.
Kui mikrokontrolleril juba tulukesed vilkuma said, oli järgmiseks alglaaduri
põhifunktsionaalsus - teise programmi alglaadimine. todo: jätkata seda kirjeldust
natuke.

\subsection{Suurimad probleemid}
\subsubsection{Viga päises}
Mikrokontrolleri riitvaraga suhtlemine käib läbi kontroll- ja staatusregistrite,
mis asuvad lihtsalt kusagil programmi aadressiruumis. Lihtsustamaks nendega
suhtlemist teevad mikrokontrolleri tootjad tavaliselt C päisfailid, kus on iga
mooduli jaoks defineeritud tema registrite aadressid. Nii ei pea igaüks eraldi
oma koodis neid aadresse meelde jätma, vaid kasutab olemasolevaid päisfaile. See
muudab ka kirjutatava koodi loetavamaks.

Töö autor kopeeris alglaaduri jaoks need registrite nimesid ja aadresse siduvad
päisfailid ühest STMicroelectronicsi näidisprojektist. Testides ja
implementeerides \iic suhtlust CAMi prototüübil, tekkis probleem, et asi
lihtsalt ei töödanud. Pärast mitmeid tunde vea otsimist leiti, et
sisend/väljund viigud ei ole õigesti seadistatud, et \iic moodul saaks neid
kasutada. Kui kõik teised veakohad olid välistatud, avastati vea tegelik põhjus.
Nimelt oli viga tootja poolt tehtud päises. Viikude seadmistamisega
riistvaramoodulile seotud registrile vahetult eelneva registri suurus oli päises
32 bitti, kuid manuaalis oli kirjas, et see on 16bitine register. See tähendas,
et vajalikust registrist kirjutati 16 biti võrra mööda. 
\subsubsection{\textit{Chip Write Enable}}
Kui \iic suhtlus CAMi prototüübil toimima saadi ja suhtlus FRAMiga toimus, siis
asuti seda sama tegema ka CDHSi plaadil. Riistvaraline \iic moodul ise oli küll
samasugune, aga sisend/väljund viikude seadistamine oli natuke erinev. Tundus
nagu asi töötaks, aga FRAMi kirjutades ja siis lugedes ei olnud tagasiloetavad
andmed samad, mis sinna kirjutati.

Tagantjärele oli vea põhjus suhteliselt ilmne, kuid sellegipoolest kulus palju
aega enne, kui veale jällile jõuti. Nimelt oli kasutataval FRAMi kiibil eraldi
jalg, mis pidi olemas kindlas asendis, et FRAMi kirjutamine töötaks. CAMi
plaadil oli see jalg jäädavalt õigesse asendis, aga CDHSi peal oli see viik
ühendatud mikrokontrolleri viigu külge ja nii pidi tarkvara selle viigu enne
kirjutamist FRAMi õigesse asendisse panema.

\subsubsection{\textit{SPI slave select}}
Kui selgus, et siiski on vaja CDHSi peal kasutada SPI siinil olevat FRAMi,
esines ka selle implementeerimisel üks rohkem silumiseks aega võtnud probleem.
Kuna töö autorile öeldi ainult alglaaduri tööks vajaminevate asjade kohta, siis
jäi SPI siinil olevate teiste seadmete \textit{slave select} viigud
seadistamata. Ossilosgraafiga SPI suhtlust vaadates leiti, et tagasitulevad
andmed on küll väga imelikud, kuid neis on mingi loogiline struktuur. Tuli
välja, et SPI siinil olev reaalajakell üritas samal ajal koos FRAMiga andmeid
tagastada. Probleemi lahendus oli jällegi lihtne: määrati kõigi SPI siinil
olevate seadmete valimise viigud mitteaktiivseks. Ja alglaaduri töö ajal muudeti
ainult FRAMiga suhtlemise ajaks FRAMile vastavat seadme valimise viigu väljundit.

\section{Teadaolevad vead}
Käesoleva dokumendi kirjutamise ajal on Estcube-1 juba Maa orbiidil ja enam ei
jää üle muud, kui vead lihtsalt dokumenteerida.
\subsection{Puuduoleva tarkvara pildi kontrollsumma arvutamine}
Kui juhtub selline asi, et alglaadur tahab kontrollida näiteks tühjas välkmälu
pesas oleva tarkvara pildi kontrollsummat, siis loeb ta päisest, et tarkvara
suurus on 0xFFFF FFFF baiti ja hakkab seda arvutama. Tegelikult tuleks
fontrollida, et tarkvara oleks mõistlikku pikkusega. Sobivaks maksimumiks oleks
näiteks tarkvarapesa maksimaalne pikkus.

Sama probleem esineb ka siis, kui enne FRAMist välkmällu kopeerimist hakatakse
kontrollima FRAMis oleva tarkvara pildi kontrollsummat.

\subsection{Südamelöögi genereerimine}
Südamelöögi genereerimisel on tegelikult kaks probleemi, millest esimene on küll
lihtne lohakusviga. Nimelt jäi CAMi versioonil südamelöögi signaali
genereerimiseks kasutataval funktsiooni keha tühjaks. Seega CAMi peal alglaadur
ei genereeri ühtegi lööki.

Teine probleem tulenes sellest, et suhteliselt lõppfaasis oli vaja CDHSi peal FRAMiga
suhtlus ümber teha SPI andmesiini peale. Ja nii jäi sinna südamelöögi signaali
genereerimine lisamata. See võib olla probleem, kui näiteks kopeerimise käsu
ajal kõigepealt välises FRAMis oleva tarkvara pildi kontrollsummat arvutatakse
ja selle vältel ühtegi südamelöögi signaali ei genereerita. Aga on võimalik, et
see ajavahemik pole nii pikk, et toitesüsteem selle peale taaskäivituse teeks.

Nende kahe probleemi leevendamiseks võib öelda, et alglaaduri tegemise ajal
polnud toitesüsteemis südamelöögi jälgimine veel implementeeritud ja töö autor
pole kindel, kas selleni üldse jõuti.

\label{sec:prob:beat}
\section{Mida tulevikus paremini teha?}
\subsection{Programmi ettevalmistamine}
Peatükis~\ref{sec:boot:prep} kirjeldati, miks on vaja programm linkida kindlale
mäluaadressile. Samas on teada, et kompillaatorid suudavad genereerida ka koodi,
mis ei sõltu positsioonist. Üheks järgmiseks uurimissuunaks on kontrollida, kas
see töötab nagu soovitud. Katkestusvektorite tabel ise on siiski koht, kus on
kindlalt absoluutsed aadressid, kuid samas võib alglaadur tarkvara kopeerimise
ajal ise need aadressid siis vastavalt programmi asukohale transleerida. See
võimaldaks selle, et üks satelliidile üleslaetud tarkvara pilt oleks kasutatav
nii sisemise välkmälu primaarses kui ka sekundaarses pesas.

\section{Kokkuvõte}
todo: kirjuta kokkuvõte
\section*{Bootloader for Estcube-1 Command and Data Handling System and Camera module}
\addcontentsline{toc}{section}{Summary}
\begin{center}
\bf Bachelor Thesis (6 ECTS)\\
Karl Tarbe\\
Summary
\end{center}

\section*{Tänusõnad}
\addcontentsline{toc}{section}{Tänusõnad}
Indrek Sünter oli see inimene, kes oli autori kontaktisik satelliidi meeskonnas.
Tema tegeles CDHSi põhitarkvara kirjutamisega ja seega oli tema põhiline
,,klient'', kelle vajadusi alglaadur rahuldama pidi. Ta aitas arutada ja nõudeid
paika panna, samuti luges ta elektriskeemidelt ette vajalikud sisend/väljund
viigud ning aitas prototüüpide ühendamisel. Suured tänud talle!

Lisaks saab tänu osaliseks autori hea sõber Mihkel Heidelberg, kes autorile selle
teema soovitas.

\label{viited}
\bibliographystyle{plain}
\bibliography{viited}

\pagebreak
\section*{Lihtlitsents lõputöö reprodutseerimiseks ja lõputöö üldsusele
kättesaadavaks tegemiseks}

Mina Karl Tarbe (sünnikuupäev: 20.02.1991)
\begin{enumerate}
	\item
		annan Tartu Ülikoolile tasuta loa (lihtlitsentsi) enda loodud teose\\
		,,Alglaadur ESTCube-1 käsu- ja andmehaldussüsteemile ja
		kaameramoodulile'',\\
		mille juhendaja on Meelis Roos,
		\begin{enumerate}
			\item 
				reprodutseerimiseks säilitamise ja üldsusele kättesaadavaks
				tegemise eesmärgil, sealhulgas digitaalarhiivi DSpace-is
				lisamise eesmärgil kuni autoriõiguse kehtivuse tähtaja
				lõppemiseni;
			\item
				üldsusele kättesaadavaks tegemiseks Tartu Ülikooli
				veebikeskkonna kaudu, sealhulgas digitaalarhiivi DSpace'i kaudu
				kuni autoriõiguse kehtivuse tähtaja lõppemiseni.
		\end{enumerate}
	\item
		olen teadlik, et punktis 1 nimetatud õigused jäävad alles ka autorile.
	\item
		kinnitan, et lihtlitsentsi andmisega ei rikuta teiste isikute
		intellektuaalomandi ega isikuandmete kaitse seadusest tulenevaid õigusi.
\end{enumerate}

Tartus, \textbf{07.05.2013}


\end{document}
