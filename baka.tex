\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[estonian]{babel}
\usepackage{cite}
\usepackage[hidelinks]{hyperref}
\usepackage[xindy,toc,acronym,nonumberlist]{glossaries}

\title{Alglaadur ESTCube-1 käsu- ja andmehaldussüsteemile ja kaameramoodulile}
\author{Karl Tarbe}

% I2C
\newcommand{\iic}{I${}^2$C}

% glossary items
\newacronym[sort={IIC}]{i2c}{\iic}{\textit{Inter-Integrated Circuit}}
\newacronym{spi}{SPI}{\textit{Serial Peripheral Interface}}
\newacronym{cam}{CAM}{\textit{Camera module}}
\newacronym{cdhs}{CDHS}{\textit{Command and Data Handling System}}
\newacronym{sram}{SRAM}{\textit{Static Random Access Memory}}
\newacronym{fram}{FRAM}{\textit{Ferroelectric Random Access Memory}}
\renewcommand*{\glspostdescription}{}
\makeglossaries
\deftranslation{Acronyms}{Lühendid}

\begin{document}
\begin{titlepage}
\begin{center}
	{\large TARTU ÜLIKOOL\\
MATEMAATIKA-INFORMAATIKA TEADUSKOND\\
Arvutiteaduse instituut\\
Informaatika eriala}
\vskip4cm
{\large Karl Tarbe}\\[6mm]
{\huge\bf Alglaadur ESTCube-1 käsu- ja andmehaldussüsteemile ja kaameramoodulile}\\[4mm]
{\large Bakalaureusetöö (6 EAP)}
\end{center}
\vspace{2cm}
\begin{flushright}
	\large
	Juhendaja: Meelis Roos, MSc
\end{flushright}
\vspace{2cm}
\begin{tabular}{l p{8cm} r}
	Autor: & \dotfill & "\dots" mai 2013\\
	Juhendaja: & \dotfill & "\dots" mai 2013\\[6mm]
	\multicolumn{2}{l}{Lubatud kaitsmisele}\\
	Professor: & \dotfill & "\dots" mai 2013\\
\end{tabular}
\vfill
\centerline{Tartu 2013}
\end{titlepage}
\setcounter{page}{2}
\tableofcontents

\printglossaries
\newpage

\section{Sissejuhatus}
Aasta 2008 suvel alustati tudengisatelliidi projektiga. Esialgu pidi tegemist
olema väga lihtsa satelliidiga, kus peal on võib-olla üks või kaks
mikrokontrollerit, kuid asjad nii ei läinud. Inseneridele meeldib ikka üle
töötada ja asju paremaks teha. Seetõttu sai ka Eesti esimesest satelliidist päris
keeruline süsteem, mis koosneb mitmetest moodulitest. Kuna tegemist on üpris
keerulise süsteemiga, peab ka selle juhtimiseks kasutatav tarkvara keeruline
olema ja iga keerulise tarkvara puhul esineb tavaliselt vigu. Siinkohal muutubki
aktuaalseks alglaadur, mille abil saab tarkvara uuendada.

Töö eesmärgiks on disainida ja realiseerida alglaadur, mille kaasabil on
võimalik uuendada ESTCube-1 käsu ja andmehaldussüsteemil ja kaameramoodulil
olevaid tarkvarasid. Täpsemalt peab alglaadur töötama kahel erineval moodulil,
kus alglaadurit jooksutavad sarnased mikrokontrollerid.

Alglaadur ei pea suhtlema maajaamaga uue tarkvara vastuvõtmiseks. On tehtud
eeldus, et olemasolev tarkvara võtab järgmise tarkvara versiooni vastu ja
salvestab selle mikrokontrollerist väljajäävasse mällu ning annab alglaadurile
käsu see mikrokontrolleri mällu kopeerida. Seega alglaaduri peamiseks ülesandeks
on lugeda välisest mälust ja kirjutada mikrokontrolleri sisemisse mällu ning
seejärel hüpata ülejäänud tarkvara käivitamise protseduuri. Väga oluline on ka
see, et iga tegevuse kohta peetaks logi, mida saab hiljem vigade
väljaselgitamiseks lugeda.

Üheks töö osaks on luua teek, mille abil saab alglaadurile käske ette valmistada
ning alglaaduri poolt kirjutatud logi lugeda. Alglaaduri ülejäänud süsteemi
integreerimine ei kuulu töö skoopi.

Töö autori panus on alglaaduri ja seda abistava teegi
\begin{itemize}
	\item nõuete väljaselgitamine,
	\item tehniliste lahenduste disain,
	\item realiseerimine.
\end{itemize}

\subsection{ESTCube-1}
Tudengisatelliidi projekti käigus valminud satelliidi nimeks on ESTCube-1.
Tegemist on kuupsatelliidiga, mille mõõtmed on 10\(\times\)10\(\times\)11.35 cm
ja kaal on 1.048 kg. Satelliit vastab kuupsatelliidi standardile \cite{cubesat}.

\subsubsection{Missioon}
Aastal 2006 leiutati uudne viis, kuidas kasutada päikeselt tulevat laetud
osakeste voogu ehk päikesetuult liikumiseks. Selleks kasutatakse peenikesi
juhtmeid, mis pingestatakse päikesetuule suhtes. Sama laenguga osakesed tõukuvad
ja kokkuvõttes hakkab päikesetuul neid juhtmeid koos lennumasinaga edasi
tõukama. Analoogia põhjal tavalise tuulega kutsutakse seda juhtmete kimpu
elektriliseks päikesepurjeks. Uudne lähenemine on umbes 100 korda efektiivsem
kui hetkel planeetidevahelisteks lendudeks sobivaimad ioonmootorid
\cite{errpuri}.

ESTCube-1 missiooniks on esimest korda ajaloos katsetada elektrilist
päikesepurje kosmoses. Satelliidi pardal olev juhtmete kimp kaalub 0,2 grammi ja
on 20 meetri pikkune. Stardi ajal on juhtmed keritud kokku rulli peale, et
stardimõõtmetesse ära mahtuda. Maa orbiidil pannakse satelliit pöörlema ja
elektriline mootor kerib rulli lahti ning tsentrifugaaljõu tõttu kaugeneb
juhtmete kimp satelliidist ühtlaselt.

\subsection{Käsu- ja andmehaldussüsteem --- CDHS}
\glsreset{cdhs}
Käsu- ja andmehaldussüsteem ehk \gls{cdhs} on kavandatud satelliidi peamiseks
pardaarvutiks. Peamised arvutused, mis määravad satelliidi positsiooni, toimuvad
just \gls{cdhs}is. Lisaks salvestatakse \gls{cdhs}i igasuguseid erinevaid
andmeid, mida sõltuvalt Maa pealt tulevatele käskudele ka tagastatakse.

Süsteem koosneb nii tarkvarast kui ka elektroonikast, mille peal tarkvara
jooksutatakse. Antud bakalauresetöö raames pole põhitarkvara detailid eriti
olulised, aga elektroonika on natuke oluline. Nimelt kuuluvad \gls{cdhs}i juurde
ka mitmed mälud, kus hoitakse erinevaid andmeid. Nendest mäludest oluliseks on
ferroelektrilised juhupöördusega mälud (\gls{fram}), sest need on
radiatsioonirikkas keskkonnas mitu korda töökindlamad kui tavapärased välkmälud
(\textit{Flash memory}). Täpsemalt on mäludest juttu
alapeatükis~\ref{sec:m2lud}.

Protsessorituumaks on Cortex-M3, mis paikneb STMicroelectronics-i 
valmistatud mikrokontrolleris STM32F103, millest tuleb lähemalt juttu
alapeatükis~\ref{sec:mcu}. Üheks märkimisväärseks omaduseks \gls{cdhs}i puhul on
see, et süsteemis on osaline riistvaraline dubleeritus: trükkplaadil on kaks
identset mikrokontrollerit \cite{cdhs}. Esialgu jookseb neist üks, kuid kui
tuvastatakse, et see mikrokontroller enam ei tööta, lülitatakse ümber teisele
mikrokontrollerile. Vea tuvastamise ja ümberlülitamise eest vastutab
toitesüsteem. Lülitatakse ümber ka andmesiinid, et mikrokontrollerist
väljajäävad seadmed oleksid korraga ühenduses ainult ühe mikrokontrolleriga.

Toitesüsteemis pidi olema ka niiöelda väline valvekoer. Kui \gls{cdhs}i
mikrokontroller aegajalt ühte viiku ei vilguta, siis toitesüsteem järeldab, et
\gls{cdhs} on määramata olekus. Toitesüsteem taaskäivitab \gls{cdhs}i sellelt
ajutiselt toite äravõtmise abil. Seda signaali, mida \gls{cdhs} genereerima
peab, nimetatakse südamelöögi signaaliks, sest kui seda signaali pole, siis on
süsteem ,,surnud'', nagu ilma südamelöökideta oleks surnud ka inimene.

\subsection{Kaameramoodul --- CAM}
\glsreset{cam}
Kaameramoodul ehk \gls{cam} on disainitud tegema pilte kontrollimaks, kas
päikesepurje väljakerimine õnnestub nii nagu soovitud. Sekundaarne ülesanne on
teha Maast ja ka Eestist pilte, mida saaks kasutada teaduse populariseerimise
eesmärgil. Pilte saab teha VGA lahutusega ehk 640\(\times\)480 pikslit, mida on
tänapäeval küll väga vähe, kuid piisavalt, et etteantud ülesandeid täita
\cite{cam}.

Sarnaselt \gls{cdhs}iga juhib mooduli tööd mikrokontroller, mille tootjaks on
STMicroelectronics. Mikrokontrolleriks on STM32F217, mis ei erine eriti
\gls{cdhs}i peal kasutatavast STM32F103st, kuid nendest erinevustest lähemalt
saab lugeda alapeatükist~\ref{sec:mcu}.

Teine sarnasus \gls{cdhs}iga on see, et ka \gls{cam}il on mikrokontrollerist
välja\-jäävad mälud. Täpsemalt on alglaaduri jaoks oluline, et \gls{cam}il asub
\gls{fram} tüüpi mälu, millega mikrokontroller saab suhelda üle \gls{i2c}
andmesiini.  Ka \gls{cam}i jaoks on toitesüsteemis eraldi signaal, kuhu
\gls{cam} peab südamelööke genereerima täpselt samamoodi, nagu seda teeb
\gls{cdhs}.

\subsection{Mälud}
\label{sec:m2lud}
Alglaadur puutub kokku kolme tüüpi mäludega, mida on kirjeldatud järgne\-vates
jaotistes.

\subsubsection{Juhupöördusega staatiline mälu --- SRAM}
\Gls{sram} on hävimälu ehk seal olevad andmed kaovad, kui mälul ei ole voolu.
Mälu asub mikrokontrolleri sees ja seda kasutab programm tavapärase
operatiivmäluna.  Kasutusel olevad mikrokontrollerid lubavad sealt ka
koodi käivitada, aga seda funktsionaalsust alglaaduris ei kasutata.

\subsubsection{Välkmälu --- Flash}
Tegemist on enimlevinud tehnoloogiaga säilmälude hulgas. Antud juhul paikneb
seda tüüpi mälu mikrokontrolleri sees. Seal asub tarkvara, mida mikroprotsessor
asub käivitama. Antud mikrokontrollerite puhul on mälu juhupöördusega nii
kirjutamiseks kui ka lugemiseks, aga kirjutamiseks peab mälu olema eelnevalt
kustutatud. Kustutatud mälus iga biti väärtus 1. \Gls{cdhs}i peal kasutatava
STM32F103 mikrokontrolleril toimub välkmälusse kirjutamine alati 16 biti kaupa.
\gls{cam}il kasutataval STM32F217l saab valida järgnevate pikkuste vahel: 64,
32, 16 või 8 bitti \cite{f2fpm}. See valik sõltub ka olemasolevast toitepingest,
kuid et STM32F103 peal valikut ei ole ja alglaadur peab mõlema peal töötama,
siis sarnasuse huvides on valitud STM32F217 korral samuti 16-bitine pikkus.

Välkmälu on jagatud mälulehtedeks, mis võivad olla kõik sama suurusega nagu
STM32F103l või ka erineva suurusega nagu STM32F217l. Välkmälust kustutamine
toimub antud mikrokontrollerite puhul kas terve mälu või ühe mälulehe kaupa.
STM32F103 puhul nimetatakse mälulehti mälulehtedeks (\textit{memory page}), aga
STM32F217 dokumentatsioonis on kasutusel termin mälusektor (\textit{memory
sector}) \cite{f1fpm,f2fpm}.

\subsubsection{Ferroelektriline juhupöördusega mälu --- FRAM}
\gls{fram} on sarnaselt välkmäluga säilmälu, kuhu jäävad andmed alles ka siis, kui
seadmelt toide ära võtta. Nii \gls{cdhs}il kui ka \gls{cam}il jääb \gls{fram}
mikrokontrollerist väljapoole ja sellega tuleb suhelda üle \gls{spi} või
\gls{i2c} andmesiini.

\gls{fram}il on mitmeid eeliseid välkmälu ees:
\begin{itemize}
	\item lubatud ülekirjutamise tsükleid on rohkem,
	\item voolutarve on kordades väiksem,
	\item kiirus on kordades parem,
	\item mälu on juhupöördusega,
	\item mälu on radiatsioonikindlam.
\end{itemize}
\Gls{fram}il on ka kaks miinust: esiteks on andmetihedus suhteliselt väike ja
teiseks on selle hind kõrgem. Seda tüüpi mälu kasutatakse satelliidil, sest see
on radiatsioonikindlam \cite{fram}.

\subsection{Mikrokontrollerid STM32F103 ja STM32F217}
\label{sec:mcu}
Mikrokontrollerid STM32F103 ja STM32F217 on STMicroelectronics-i tooted,
mida kasutatakse vastavalt \gls{cdhs}il ja \gls{cam}il. Kogu järgnev tekst siin
jaotises viitab mikrokontrollerite tehnilistele manuaalidele \cite{f1rm,f2rm}.
Esimene osa kirjeldab kontrollerite ühisosa ja teine kirjeldab nende
erinevusi. Alglaaduri tööks mittevajalikud osad jäävad kirjeldamata.

Lisatäpsustena peab mainima, et käesolevas töös kasutatakse nimetusi STM32F103
ja STM32F217 konkreetsete mikrokontrollerite nimedena, kuid tegelikult
tähistavad need kahte erinevat mikrokontrollerite seeriat. Samasse seeriasse
kuuluvad mikrokontrollerid erinevad mälumahtude,
sisend-/väljund\-vii\-ku\-de arvu või kontrolleri füüsilise pakendi poolest.

\subsubsection{Sarnasused}
\label{sec:mcu:same}
Mõlemas kontrolleris on protsessorituumaks ARM arhitektuuriga Cortex-M3,
mis on väga tihedalt seotud katkestustekontrolleriga. Täpsemalt saab selle kohta
lugeda manuaalist \cite{CM3pm}.

Mikrokontroller erineb mikroprotsessorist selle poolest, et lisaks
mikroprotsessorile on mikrokontrolleris olemas ka ülejäänud vajalik, et tööd
teha: operatiivmälu, mälu tarkvara jaoks ja mitmed moodulid välise maailmaga ehk
väliste seadmetega suhtlemiseks. Mõned moodulid, mida alglaadur oma töös
kasutab, on õnneks kasutamise seisukohalt mõlemas kontrolleris täpselt
samasugused.

Üheks selliseks mooduliks on kontrollsumma arvutamise üksus (\textit{CRC
calculation unit}), mille abil saab arvutada 32-bitist kontrollsummat(CRC-32).
On mitmeid erinevaid standardeid, mille järgi CRC-32te arvutada. Antud moodul
kasutab Ethernetis ja mujal kasutusel olevat polünoomi, mille väärtus
kuueteistkümnendsüsteemis on 0x4C11DB7.

Kuna alglaadur peab suhtlema väliste mäludega üle \gls{i2c} ja \gls{spi}
andmesiinide, on oluline ka see, et mõlema jaoks on eraldi moodulid olemas. Ilma
eraldiasuva moodulita peaks raiskama protsessoriaega, et ükshaaval erinevaid
sisend-/väljundviike juhtida, mis on küll võimalik, kuid ebaefektiivne, sest
protsessor peab ühe andmevahetuse kella takti jooksul täitma mitmeid
käske ja seega on andmevahetuse üldine kellasagedus kümneid kuni sadu
kordi väiksem kui protsessori kellasagedus.

Käesoleva töö kontekstis on oluline, et alglaadimise protseduur on mõlemal
kontrolleril samasugune ja see on kirjeldatud peatükis~\ref{sec:boot}.

\subsubsection{Erinevused}
Peamiseks erinevuseks on see, et maksimaalne lubatud töösagedus protsessorile on
STM32F103 korral 72MHz ning STM32F217 korral 120MHz. Alglaaduri seisukohalt pole
see aga oluline, sest alglaadur kasutab kogu oma töö vältel madala sagedusega
sisemist kellasignaali. Sisemise kellasignaali sagedus on 8 MHz.

Alglaaduri seisukohalt oluliseks erinevuseks on sisemise välkmälu erinev
ülesehitus. STM32F103l on välkmälu jagatud kaheks mälupangaks (\textit{memory
bank}), millele on juurdepääsuks erinevad registrid, aga STM32F217l on üks
mälupank. Lisaks sellele on esimese kontrolleri puhul kõik mälulehed sama
suurusega, kuid teises kontrolleris on mälulehtede suurused varieeruvad
\cite{f1fpm,f2fpm}.

Erinev on ka sisend-/väljundviikude seadistamine. Erinev on nii
lihtsalt viikude seadistamine kui ka mingite viikude määramine riistvara
moodulitele kasutamiseks.

\section{Süsteemi nõuded}
Käesolevas peatükis on välja toodud alglaadurile alguses paika pandud nõu\-ded ja
kasutusjuhud. Need sündisid koostöös \gls{cdhs}i arendaja Indrek Sünter\-iga.
Lisasoovitusi andsid akadeemilised nõustajad Viljo Allik ja Tõnis Eenmäe.
Siin peatükis pole eriti räägitud \gls{cam}ist, sest alglaadur on mõeldud
eelkõige \gls{cdhs}ile. \Gls{cam}il kasutatakse lihtsalt sama alglaadurit.

\subsection{Alglaaduri käsud}
\subsubsection{Käsk kindla tarkvara alglaadimiseks}
Käsk on vajalik, et vahetada kasutatavat tarkvara. Käsu abil saab valida,
millises pesas olev tarkvara alglaaditakse.

\subsubsection{Käsk tarkvara kopeerimiseks}
Käsk on vajalik, et saaks teostada tarkvara uuendamist, kui \gls{cdhs} töötab.
Käsu eesmärk on kopeerida tarkvara tõmmis välisest mäluseadmest sisemisse
välkmällu.  Enne kopeerimist tuleb valideerida tarkvara tõmmise terviklikkus.

\subsection{Alglaaduri käskude loend}
Kuna alglaaduriga ei suhtle vahetult teine seade, vaid põhitarkvara ise, siis on
vajalik, et oleks olemas loend, kuhu põhitarkvara paneb alglaadurile täit\-mi\-seks
mõeldud käsud.
\subsubsection{Käskude lisamine loendisse}
Käske peab saama loendisse lisada, sest muidu ei oleks võimalik alglaadurile
käske anda. Käskude lisamise eelduseks on see, et põhitarkvara töötab.

\subsubsection{Vigade logimine}
Vigade logimine on vajalik, et vigadest teada saada. Kui mõne alglaaduri käsu
täitmine ebaõnnestub, tuleb vea info logisse salvestada.

\subsubsection{Vaikimisi alglaadimine}
Enamasti on alglaaduri käskude loend tühi ja selleks ajaks on vaja head ja
ohutut vaikimisi käitumist, mis alglaadiks olemasoleva tarkvara.

\subsubsection{Õnnestumise logimine}
Kui midagi alglaaduri töös halvasti läheb, siis on vaja teada, mille alglaadur
edukalt juba korda saatis.

\subsubsection{Käskude loendi valideerimine}
Radiatsiooni või mingi muu nähtuse tõttu võib käskude loend kahjustada saada.
Vigaste käskude täitmise vältimiseks tuleb käskude loendi terviklikkus üle
kontrollida.

\subsection{Alglaaduri töö}
\subsubsection{Välisest mälust lugemine}
Sisemises välkmälus pole piisavalt ruumi, et hoida piisavat arvu tagavara
tarkvara tõmmiseid. Seega peab alglaadur suutma väliste mäluseadmetega suhelda.

\subsubsection{Sisemisse välkmällu kirjutamine}
Mikrokontroller suudab koodi jooksutada ainult sisemisest välkmälust või
\gls{sram}ist, seega peab alglaadur suutma paigutada tarkvara sinna, kus seda saab
käivitada ja hoiustada.

\subsubsection{Tarkvara kontrollsumma kontrollimine kopeerimisel}
Tarkvara võib välises mälus kahjustada saada, seega tuleb enne kopeerimist
kontrollida, kas kontrollsumma klapib, et tagada tarkvara tõmmise terviklikkus.

\subsubsection{Tarkvara kontrollsumma kontrollimine alglaadimisel}
Tarkvara võib sisemises välkmälus kahjustada saada ja vigast tarkvara ei tohiks
käima panna.

\subsubsection{Südamelöögi pakkumine}
Alglaadur peab genereerima südamelöögi signaali, et toitesüsteem ei püüaks
toitepinget eemaldades \gls{cdhs}ile taaskäivitust teha.

\subsubsection{Tarkvarapesa valimine kasutades CDHS\_FIRM signaali}
Vea korral peab olema toitesüsteemil võimalus valida teine \gls{cdhs}i tarkvara
tõmmis. Selleks muudab toitesüsteem signaali CDHS\_FIRM väärtust. Alglaadur
saab selle väärtuse teada vastavat sisendviiku lugedes.

\subsubsection{Kahe mikrokontrolleri toetamine}
Alglaadur peab töötama nii STM32F103l, mis on \gls{cdhs}il, kui STM32F217l, mis
on \gls{cam}il.

\subsection{Kasutuslood}
Siin on esitatud esialgsed kasutuslood, mis kirjeldavad seda, kuidas ,,tellija''
ehk CDHSi peaarendaja, Indrek Sünter alglaaduri kasutamist ette nägi.
\subsubsection{Tavapärane alglaadimine}
\label{sec:usecase:default}
\begin{enumerate}
	\item Protsessor laadib alglaaduri.
		\begin{enumerate}
			\item Kõik lisaseadmed ja riistvaramoodulid lülitatakse välja.
			\item Kõik sisend-/väljundviigud seatakse analoogsisendiks.
			\item Valvekoera taimer (\textit{Watchdog Timer}) seadistatakse.
			\item Lihtsad \gls{i2c} \gls{fram}i ajurid laaditakse.
			\item Kontrollsumma moodul seadistatakse.
			\item Südamelöögi signaal seadistatakse.
			\item Alglaadur kontrollib iseenda kontrollsummat.
			\item Alglaadur võtab esimese käsu, valideerib ja täidab selle.
			\item CDHSi tarkvara alglaaditakse.
			\item CDHSi tarkvara loeb alglaaduri logi ja kopeerib sealt
				huvitavad elemendid oma vigade logisse.
		\end{enumerate}
\end{enumerate}

\subsubsection{CDHSi tarkvara uuendamine}
\label{sec:usecase:upgrade}
\begin{enumerate}
	\item Uue tarkvara tõmmis hoiustatakse välises \gls{fram}is ning CDHS
		taaskäivitatakse koos
		\begin{enumerate}
			\item käsuga alglaadurile, et kopeerida see mikrokontrolleri
				sisemisse välkmälusse.
		\end{enumerate}
	\item Alglaadur võtab esimese käsu ja täidab selle.
		\begin{enumerate}
			\item Käsuks on kopeerida tarkvara tõmmis välimisest \gls{fram}i pesast \(X\)
				sisemisse välkmälu pessa \(Y\).
				\begin{enumerate}
					\item Arvutatakse pesas \(X\) oleva tõmmise kontrollsumma ja
						võrreldakse seda pesa \(X\) päises olevaga.
						\begin{enumerate}
							\item Kopeeritakse tarkvara tõmmis pesast \(X\) pesasse \(Y\).
							\item Kontrollitakse tarkvara tõmmist pesas \(Y\) ja
								vajadusel korratakse kopeerimist kuni kolm
								korda.
							\item Logitakse õnnestumine.
						\end{enumerate}
				\end{enumerate}
		\end{enumerate}
\end{enumerate}

\subsubsection{Välisest FRAMist lugemine ebaõnnestub}
\label{sec:usecase:framerror}
\begin{enumerate}
	\item Alglaadur käivitatakse koos käsuga kopeerida tarkvara tõmmis välisest
		\gls{fram}ist.
	\item Alglaadur üritab lugeda välisest \gls{fram}ist.
		\begin{enumerate}
		\item Oletame, et \gls{fram} ei vasta, või \gls{i2c} andmesiin on hõivatud.
		\end{enumerate}
	\item \gls{i2c} viga logitakse.
	\item Käskude loend tühjendatakse.
	\item Alglaadur alglaadib vaikimisi pesas oleva tarkvara.
\end{enumerate}

\subsubsection{Kontrollsumma erinevus tarkvara tõmmisel}
\begin{enumerate}
	\item Alglaaduril käsitakse opereerida tarkvara tõmmisel (kas kopeerida või
		alglaadida).
	\item Alglaadur arvutab tarkvara tõmmise kontrollsumma.
	\item Alglaadur võrdleb seda tarkvara tõmmise päises oleva kontrollsummaga.
		\begin{enumerate}
			\item Oletame, et need ei ühti.
		\end{enumerate}
	\item Viga logitakse.
	\item Käskude loend tühjendatakse.
	\item Alglaadur valib vaikimisi tarkvara tõmmise ja proovib seda alglaadida.
\end{enumerate}

\subsubsection{Käskude loendis on tundmatu käsk}
\begin{enumerate}
	\item Alglaadur vaatab käskude loendit.
		\begin{enumerate}
			\item See ei ole tühi.
		\end{enumerate}
	\item Alglaadur võtab esimese käsu loendist.
	\item Alglaadur proovib seda verifitseerida, kuid ebaõnnestub.
	\item Alglaadur logib vea.
	\item Käskude loend tühjendatakse.
	\item Alglaadur valib vaikimisi tarkvara tõmmise ja proovib seda alglaadida.
\end{enumerate}

\subsubsection{Soovitud tarkvara tõmmis valitakse FIRMW viigu abil}
\label{sec:usecase:fwselect}
\begin{enumerate}
	\item Alglaadur vaatab käskude loendit.
	\item Käskude loend on tühi.
	\item Alglaadur vaatab FIRMW viiku.
		\begin{enumerate}
			\item See on madal?
				\begin{enumerate}
					\item Laaditakse vaikimisi pesas olev tarkvara.
				\end{enumerate}
			\item See on kõrge?
				\begin{enumerate}
					\item Laaditakse tagavarapesas olev tarkvara.
				\end{enumerate}
		\end{enumerate}
\end{enumerate}

\subsubsection{Alglaaduril ebaõnnestub vea logimine}
\begin{enumerate}
	\item Midagi juhtub ja alglaaduril ebaõnnestub vea logimine.
		\begin{enumerate}
			\item Vigade logi on täis?
				\begin{enumerate}
					\item Alglaadur ei kirjuta vanemaid sissekandeid üle.
				\end{enumerate}
		\end{enumerate}
	\item Alglaadur jätkab tööd probleemi ignoreerides.
\end{enumerate}

\subsubsection{Spetsiifilise tarkvara tõmmise alglaadimine}
\begin{enumerate}
	\item CDHS käivitab alglaaduri käsuga laadida tarkvara kindlast pesast.
	\item Alglaadur verifitseerib käsu.
	\item Alglaadur logib õnnestumise.
	\item Alglaadur tühjendab käskude loendi.
	\item Alglaadur alglaadib soovitud pesas oleva tarkvara tõmmise.
\end{enumerate}

\subsubsection{Alglaaduri kontrollsumma erinevus}
\begin{enumerate}
	\item Alglaadur arvutab enda kontrollsumma.
	\item Alglaadur võrdleb seda varem salvestatuga.
		\begin{enumerate}
			\item Oletame, et need ei ole võrdsed.
		\end{enumerate}
	\item Viga logitakse.
	\item Alglaadur valib vaikimisi tarkvara tõmmise ja proovib seda alglaadida.
\end{enumerate}

\subsection{Muutused töö käigus}
Nagu peaaegu igale tarkvaraprojektile kohane, muutusid ka selle projekti käigus
nõuded. Nõuded täpsustusid peamiselt seetõttu, et esialgsete nõuete koostamisel
ei oldud teadlikult väga põhjalik ja esialgsed nõuded jätsid päris mitmed
detailid lahtiseks. Samuti on vasturääkivusi esitatud kasutuslugudes.

\subsubsection{Töö käigus tekkinud täpsustused}
Käskude loendi hoidmiseks valiti väline \gls{fram}, sest see on
radiatsioonikindlam kui välkmälu. Kui peaks juhtuma, et välise \gls{fram}iga ei
saa suhelda, siis pole alglaaduril võimalik sealt tarkvara kopeerida.
Tarkvaratõmmise valimiseks saab kasutada ka toitesüsteemi, mis muudab FIRMW
viigule mineva signaali väärtust.

Samuti otsutati, et ka kopeerimine toimub just \gls{fram}ist sisemisse
välk\-mä\-lusse. Väline välkmälu oli alternatiivse koht tarkvara tõmmiste
hoiustamiseks. \Gls{fram}i kasuks otsustati, sest siis ei pea realiseerima
suhtlust välise välkmäluga ja alglaaduri keerukus ei kasva selle võrra.

Algselt leiti ka veel seda, et nii \gls{cam}il kui ka \gls{cdhs}il on \gls{i2c}
siinil olev \gls{fram}.  See tähendas, et oli vaja realiseerida ainult \gls{i2c}
suhtlus. Hiljem avastati, et \gls{cdhs}i \gls{i2c} andmesiinil olev
\gls{fram} on liiga väike, et seal tarkvara tõmmiseid hoida.  Seetõttu tuli
realiseerida ka \gls{spi} siinil suhtlus \gls{fram}iga, sest \gls{cdhs}i peal
oli \gls{spi} siinil piisava suurusega \gls{fram}. Teisest küljest \gls{cam}il
ei ole \gls{spi} siinil asuvat \gls{fram}i ja seega jäädi seal \gls{i2c} siinil
oleva \gls{fram}i juurde.

\subsubsection{Kasutuslugude muutused}
Kasutusloos~,,\ref{sec:usecase:default}~\nameref{sec:usecase:default}'' pole
vaja teha kahte esimest tegevust, sest pärast mikrokontrolleri resetti on niigi
kõik lisaseadmed välja lülitatud ja enamik sisend-/väljundviikudest on
seadistatud analoogsisendiks \cite{f1rm,f2rm}. Lisaks leiti töö käigus, et
sisemist valvekoera taimerit ei peaks kasutatama, sest kui \gls{cdhs}i tarkvara
kokku jookseb, teeb valvekoer mikrokontrollerile taaskäivituse. Kui tarkvara
järjepidevalt uuesti hangub, siis jääb süsteem taaskäivituste tsüklisse. Kui
nüüd selle tsükli käigus ka südamelöögi signaali genereeritakse, siis ei saaks
toitesüsteem probleemist teada ja ei oskaks ümber lülitada teisele tarkvara
pesale või \gls{cdhs}i puhul teisele mikrokontrollerile. Samuti on vajab
kohendamist ka punkt (d), sest \gls{cdhs}il saab \gls{fram}ile ligi \gls{i2c} asemel
üle \gls{spi} andmesiini.

Kasutusloos~,,\ref{sec:usecase:upgrade}~\nameref{sec:usecase:upgrade}'' ei ole
vaja välimises \gls{fram}is kindlat pesa määrata, vaid selle asemel kasutatakse
lihtsalt mälu\-aadressi, millelt tarkvara tõmmis leitakse.

Kasutuslugu~,,\ref{sec:usecase:framerror}~\nameref{sec:usecase:framerror}''
tuleb ka muuta, sest \gls{fram} ei pruugi alati olla \gls{i2c} siinil ning enne
kopeerimise käsku tuleb \gls{fram}ist lugeda käskude loend. Samuti on käskude
loendi kustutamiseks vaja \gls{fram}i kirjutada.

Kasutusloost~,,\ref{sec:usecase:fwselect}~\nameref{sec:usecase:fwselect}''
eemaldati tingimus, et käskude loeng peab olema tühi.  Lihtsalt iga kord, kui on
juttu vaikimisi pesas oleva tarkvara alglaadimisest, siis valitakse pesa
vastavalt selle viigu väärtusele. Koodis on tagavarapesa asemel leebem nimetus:
sekundaarne pesa.

\section{Alglaadimine}
\label{sec:boot}
\subsection{Tavapärane programmi käivitamine}
\label{sec:boot:tava}
Käesolevas alapeatükis kirjeldatakse protsessori tööd programmi käivitamisel.

Mikrokontroller üritab ennast tööle panna, kui toide olemas on. Esmalt
lülitatakse sisse sisemine 8-MHz-ne ostsillaator, mille signaali neljandal
tõus\-val frondil loetakse konfigureerimise viikude väärtused. Nende väärtuste
põh\-jal otsustab mikrokontrolleri sisemine juhtloogika, millisest kohast programm
käivitada. Võimalikud variandid on: põhi-välkmälu, süsteemi mälu ja staatiline
juhupöördlusega mälu (\gls{sram}).  Enim kasutatakse kahte esimest:
põhi-välkmälu seal oleva programmi käivitamiseks ja süsteemi mälu. Süsteemi mälu
on kaitstud osa põhi-välkmälu lõpust, kuhu tehases paigaldatakse alglaadur,
mille abil saab programmeerida ülejäänud välkmälu. Tehases paigaldatud alglaadur
võimaldab mikrokontrollerile oma tarkvara peale laadida.

Edasist protsessi vaatleme tehes oletuse, et programm on juba kontrolleri
välkmälus olemas ja alglaadimist alustatakse põhi-välkmälust. Välkmälu aadress
on tegelikult 0x800 0000, aga viikude oleku tõttu peegeldatakse välkmälu
aadressiruum ka aadressile 0x0000 0000. See tähendab, et mälu\-ope\-rat\-sioon
aadressiga 0x0000 0000 annab sama tulemuse, mis ta annaks aadressiga 0x800 0000.
Protsessor võtab aadressil 0x0000 0000 oleva väärtuse ja kasutab seda pinu viida
(\textit{stack pointer}) algväärtustamiseks. Seejärel alustatakse käskude
täitmist lähtestamise rutiinist, mille algusaadressi võtab protsessor aadressilt
0x0000 0004 \cite{f1rm}.

Lähtestamise vektoril on tavaliselt assembleris kirjutatud protseduur, mis
kopeerib programmi andmete sektsiooni välkmälust \gls{sram}i, täidab ülejäänud
programmi jaoks vajaliku ala \gls{sram}ist nullidega, kutsub välja C koodis
kirjutatud protseduuri, mis initsialiseerib süsteemi kella, ja siis annab
juhtimise üle C koodis kirjutatud \textit{main} protseduurile. Satelliidi peal
ei kasutata üldist kella seadmise koodi ja seega see samm jäetakse vahele ning
kella seadmine kutsutakse välja \textit{main}ist.

See, mida tarkvara edasi initsialiseerib, on juba tarkvara spetsiifiline.
Tõenäoliselt initsialiseeritakse mõned riistvaralised moodulid näiteks USART või
\gls{spi} ning hakatakse siis rakendusele spetsiifilist kontrolltsüklit täitma.
Satelliidil ESTCube-1 kasutatakse nii \gls{cam}il kui ka \gls{cdhs}il
põhitarkvara osana reaalaja operatsioonisüsteemi FreeRTOS.

\subsection{Programmi alglaadimine koos alglaaduriga}
Alglaadur ise käitub alglaadimise seisukohalt nagu iga teinegi programm ja
laaditakse täpselt samamoodi nagu eelmises alapeatükis kirjeldatud. See tähendab
seda, et alglaaduri katkestusvektorite tabel peab asuma välkmälu alguses, sest
sealt hakkab protsessor seda otsima. Kuna üks osa alglaadurist asub juba
välkmälu alguses, on ka teised osad sinna järele paigutatud, mis omakorda
tähendab, et tegelik põhiprogramm peab nüüd asuma kusagil mujal kui välkmälu
alguses ja sellega peab arvestama põhiprogrammi linkimisel.

Kui alglaadur on oma muud ülesanded juba täitnud, on selle viimaseks tööks
põhitarkvara käivitamine. Selleks jäljendab alglaadur protsessori käitumist,
kuid kõigepealt on vaja teada, mis aadressil põhitarkvara katkestusvektorite
tabel asub. See aadress on eelnevalt kokku lepitud ja sissekodeeritud.

Enne põhitarkvara töölepanemist tuleks puhtaks teha pinu. Alglaaduri enda töö
ajal sinna salvestatud väärtusi pole põhiprogrammil vaja, sest
ideaalis ei tohiks põhiprogramm arugi saada, kas see käivitati otse või
alglaaduri abiga. Pinu puhtaks tegemine tähendab lihtsalt pinu viida
algväärtustamist, sest nii hakatakse edaspidi pinus juba olevaid andmeid üle
kirjutama ja kui programm on korrektne, siis midagi sellist ei loeta, mida
programm ise pole juba üle kirjutanud. Algväärtustamiseks kasutatakse
põhitarkvara katkestusvektorite tabeli esimest elementi, mis näitab pinu ülemist
aadressi.

Kuigi mikrokontrolleri käivitamise hetkel alustatakse tööd kindlast kohast, ei
pea terve katkestusvektorite tabel välkmälu alguses olema. Katkestustega tegeleb
eraldi riistvara moodul NVIC (\textit{Nested Vectored Interrupt Controller}).
Lisaks on sellega tihedalt seotud teine moodul SCB (\textit{System Control
Block}), kus asub seadistatav register VTOR (\textit{Vector Table Offset
Register}), mille väärtust kasutatakse katkestusvektorite tabeli aadressina
\cite{CM3pm}. Vaikimisi on seal väärtus 0x0000 0000, mida kasutatakse alglaaduri
laadimiseks, kuid alglaadur seab selleks väärtuseks põhiprogrammi
katkestusvektorite tabeli aadressi. Kui seda ei seadistataks, siis kutsutaks
põhiprogrammi katkestuse ajal välja alglaaduri katkestusvektoreid, mis on
tegelikult spetsifitseerimata, sest alglaadur ei kasuta katkestusi. Lisaks
sellele on vaikimisi katkestuse teenindamise rutiin lihtsalt lõputu tsükkel,
seega jääks kontroller katkestusse kinni ja halvatud ei oleks ainult
põhitarkvara katkestuse teenindamine vaid kogu põhitarkvara töö peatuks.

Kui pinu viit ja katkestusvektorite tabeli asukoht on ära seadistatud, jääb üle
lugeda katkestusvektorite tabelist põhiprogrammi lähtestamise vektor ehk
lähtestamise rutiini algusaadress ja mikrokontrolleri töö sinna edasi juhtida.
Selleks tehakse C-koodis funktsiooni viit, mis väärtustatakse lähtestamise
vektoriga ning seejärel kutsutakse see välja. Siit edasi on juhtimine juba
alglaaditava tarkvara käes ja alglaadur ei tee enne järgmist süsteemi
taaskäivitust enam midagi.

Edasine toimub sarnane tegevus nagu tavapärase programmi käivitamise juures, kus
lähtestamise vektoril olev protseduur kopeerib välkmälus oleva põhiprogrammi
andmete sektsiooni \gls{sram}i, tühjendab \gls{sram}i initsialiseerimata andmete
jaoks ja seejärel kutsub välja põhitarkvara \textit{main} protseduuri.


\subsection{Programmi ettevalmistamine}
\label{sec:boot:prep}
Selleks, et põhitarkvara saaks kasutada alglaaduriga, tuleb eelnevalt programm
niimoodi linkida, et arvestatakse sellega, millisele mäluaadressile tarkvara
hiljem pannakse. Kui programm linkida kokku aadressi 0x800 0000 jaoks ja
alglaadur paigutab programmi aadressile 0x800 3000, siis on programmi
katkestusvektorite tabelis valed väärtused. Näiteks taimeri katkestuse
käsitlemise funktsioonile vastavaks aadressiks katkestuste tabelis võib-olla
välkmälu alguses paiknev aadress 0x800 09F0. Taimerikatkestuse korral võtab
protsessor katkestusvektorite tabelist väärtuse 0x800 09F0 ja hakkab sealt käske
täitma, kuid tõenäoliselt paikneb seal mingi alglaaduri osa.

Programmi linkimise ajal peab teadma aadressi, kuhu alglaadur selle programmi
paneb. Lisaks aadressi teadmisele tuleb ka linkijale öelda, et ta programmi just
selle aadressi jaoks lingiks.

\section{Muud realisatsioonidetailid}
\subsection{Riistvara moodulitele juurdepääs}
STMicroelectronics annab koos oma mikrokontrolleritega kaasa ka abiteegid, kus
on funktsioonid, mis lihtsustavad riistvaramoodulite kasutamist. Alglaaduris neid
ei kasutata, sest need lisavad alglaaduri ja riistvara vahele ebavajaliku
lisakihi, mis raskendab silumist. Miinuseks on ka see, et abiteegid
tõstavad alglaaduri keerukust ning suurust.

\subsection{Alglaaduri kontrollsumma kontrollimine}
Alglaaduri enda kontrollsumma arvutamiseks kasutatakse riistvaramoodulit,
millest oli juttu jaotises~\ref{sec:mcu:same}.

Kui kontrollsumma on arvutatud, tuleb seda millegagi võrrelda. Selleks on
linkija skriptis alglaaduri lõppu lisatud üks 4 baidi piirile joondatud
32-bitine muutuja. Muutuja on 4 baidi piirile joondatud, sest kontrollsumma
arvutamise moodul arvutab just 4 baidi ehk 32 biti kaupa. Selle muutuja
algväärtustamisel on tehtud lisaeeldus, et alglaadur ei saa kannatada enne
esimest töölepanemist. Seda eeldust on vaja, sest linkija paneb selle väärtuseks
lihtsalt 0xFFFF FFFF ja esimesel korral, kui alglaadur oma kontrollsumma
arvutab, programmeeritakse välkmälus see väärtus üle tegeliku kontrollsummaga.
Kusjuures esialgne väärtus 0xFFFF FFFFF ei ole niisama valitud. See väärtus on
sellepärast, et selline on välkmälu kustutatud asendis, ja nii on võimalik see
üle programmeerida ilma tervet sektorit eelnevalt kustutamata.

\subsection{Tarkvara tõmmise päis}
\label{sec:impl:header}
Tarkvara tõmmist võib vaadelda, kui lihtsalt ühte suurt kogu andmeid, mille
alguses on katkestusvektorite tabel. Alglaaduri seisukohast oleks vajalik, et
oleks teada ka nende andmete pikkus ja kontrollsumma. Selleks lisatakse
tarkvara tõmmise ette nii \gls{fram}is kui ka välkmälus pisike päis, kus on kolm 32
bitist välja: suurus, versioon ja kontrollsumma. Versioonivälja alglaadur 
kunagi ei puutu, aga põhitarkvara võib sellest kasu saada.

Päise lisamine aga tekitas ühe lisaprobleemi. Nimelt on välkmälus valitud
tarkvarapesad selliselt, et need algaksid välkmälu lehtede piirilt, et neid
oleks mugav kustutada. Need on suhteliselt ümmargused aadressid, kus ümmargune
tähendab seda, et aadressi madalamad bitid on nullid. Enne päise lisamist
töötas põhitarkvara normaalselt, kuid pärast päise lisamist esinesid probleemid
põhitarkvara töös. Põhjuseks oli katkestusvektorite tabeline nihkumine päise
võrra edasi, aga katkestusvektorite tabel peab olema ka mõnevõrra ümmargusel
aadressil: 9 madalamat bitti peavad olema nullid \cite{CM3pm}.

Kompenseerimiseks lisati päise ja ülejäänud tõmmise vahele 500
baiti polstrit, mis nihutas katkestusvektorite tabeli piisavalt
ümmargusele aadressile. Selline lahendus küll töötab, kuid raiskab ära 500 baiti.
Alternatiivina oleks saanud panna selle päise pärast katkestusvektorite tabelit,
sest katkestusvektorite tabel on fikseeritud pikkusega, kuid see oleks rohkem
tööd võtnud ja samuti oleks siis pidanud eraldi arvutama kontrollsumma
katkestusvektorite tabelist ja ülejäänud osast, mis jääks teisele poole päist.

Tarkvara tõmmis koos päise ja polsterdusega on ühesugune nii \gls{fram}is kui ka
välkmälus, kuigi \gls{fram}is pole seda polsterdust vaja. Tarkvara kontrollsumma
arvutamisel ei arvutata sisse päist ega polsterdust. Polsterdust saab kasutada,
et seal veel mingeid metaandmeid tarkvara tõmmise kohta hoida, sest ka see
polsterdust kopeeritakse alglaaduri poolt kohusetundlikult \gls{fram}ist
välkmällu.

\subsection{Käskude loend}
Käskude loend asub \gls{fram}is. Kasutades alglaaduri abiteeki saab sinna kirjutada
maksimaalselt 3 käsku ja valida on kahe käsutüübi vahel: kopeerimine või
alglaadimine. Iga käsk koos oma parameetritega kirjutatakse \gls{fram}i kahekordselt,
kusjuures teine kord on kõik bitid inverteeritud. 

Et vältida vanade käskude loendisse sattumist, kirjutatakse iga käsu lõppu veel
kaks baiti, mille väärtuseks on 0xFF. See tagab selle, et käskude loendi
algusesse uue käsu kirjutamisel kirjutavad need kaks lisabaiti üle käskude
loendis varem olnud vana käsu alguse, mistõttu alglaadur ei loe kaugemale
viimati kirjutatud käskudest ka siis, kui unustatakse käskude loend eelnevalt
tühjendada.

Käskude loendi tühendamine tähendab lihtsalt maksimaalse suurusega alale
0xFFide kirjutamist. Seejuures ei eristata käskude loendit lugedes, kas
käskude loend oli tühi või lihtsalt esimene bait loendis oli vale.

Ühe puudusena võib välja tuua selle, et käskude loendit lugedes ei kontrollita,
kas on ainult kolm käsku. Seetõttu saab \gls{fram}i kirjutada ka sellise käskude
loendi, kus on näiteks sadu kopeerimiskäske, aga see ei ole probleem, sest
käskude loendit ei loeta korraga mälusse vaid täidetakse käskhaaval.


\subsection{Südamelöögi signaali genereerimine}
Südemelöögi signaali saab genereerida kasutades selleks riistvaralist taimerit,
kuid see oleks vale, sest tarkvara võib kokku joosta niimoodi, et taimer
genereerib signaali edasi. Seega on õigem tarkvarast manuaalselt seda signaali
genereerida.  Pealegi signaal ise on lihtne. Lihtsalt ühe väljundviigu väärtust
tuleb muuta piisavalt tihedalt. Ning pole oluline, kui seda tehakse
ebavajalikult tihti.

Viigu väärtust muudetakse vahetult enne põhitarkvara alglaadimist ja kahes
funktsioonis, mida kasutatakse, et oodata mingite operatsioonide lõppe\-mist.
Nendest esimene on välkmälu operatsioonide jaoks ja teine \gls{i2c} \gls{fram}i jaoks. Siit
aga tuleb välja üks probleem, mis on kirjas jaotises~\ref{sec:prob:beat}. 

\subsection{Alglaaduri logi}
\label{sec:impl:log}
Alglaaduri logi salvestatakse ühte välkmälu lehte. Igal alglaaduri käivitamisel
leitakse kahendotsinguga üles seal lehes koht, kuhu logi kirjutamine pooleli jäi
ja jätkatakse sealt logi täitmist. Kui juhtub, et käivitamise hetkel on logi
peaaegu täis, siis võetakse viimased 10 logi elementi, kopeeritakse need
\gls{sram}i, kustutatakse mäluleht välkmälus ära, ja siis kirjutatakse need 10
logi elementi logi algusesse. Samuti hoolitsetakse, et kui kuidagi peaks töö
käigus logisse rohkem kirjutatama, kui logis ruumi on, siis jäetakse ikkagi logi
alast välkmälus väljapoole kirjutamata. Mittemahtuvad logikirjed visatakse
lihtsalt minema, sest normaalse töö käigus ei tohiks logi kunagi täis saada.

\subsection{Kasutatavad tööriistad}
Alglaaduri realiseerimiseks valiti C programmeerimiskeel, sest see sobib hästi
manussüsteemide programmeerimiseks. Kasutatavale arhitektuurile on olemas
kättesaadav C kompilaator. Tööriistavööna kasutati Sourcery G++ Lite'i, mis on
\textit{GNU Compiler Collection}i(GCC) kommertsiaalne versioon ARM arhitektuuri
jaoks.

\section{Komponendid}
\Gls{cdhs}i ja \gls{cam}i tarkvara tegemiseks kasutatakse Eclipse'i. Alglaaduri
tegemiseks kasutati ka Eclipse'i, et hoida sarnast ülesehitust. Töö on jagatud
kaheks projektiks, millest üks on alglaadur ise ja teine on abiteek, mille abil
saab alglaadurile käske anda, käske lugeda ja alglaaduri logi lugeda.

\subsection{Alglaadur}
Alglaaduri projekt koosneb mitmetest failidest, mille hulgas on 9 C-faili, 4
päisefaili, 2 assembleri faili ja 2 linkimise skripti. Kuna alglaadur peab
töötama kahel erineval platvormil, siis on platvormispetsiifilised kohad koodis
kaitstud eeltöötluse makrodega (\textit{preproccesor macros}). Eeltöötluse jaoks
defineeritakse sümbolid vastavalt Eclipse projektis olevale ehitamise
seadistusele (\textit{build configuration}). See tähendab, et kompileerides
alglaadurit näiteks \gls{cdhs}i jaoks jäävad kompilaatoril nägemata need osad
koodist, mis on mõeldud ainult \gls{cam}ile, sest eeltöötluse käigus võetakse
need välja.

\subsubsection{Assembleri failid --- \textbf{startup\_stm32fxxxx.S}}
Failid \textbf{startup\_stm32f10x\_xl.S} ja \textbf{startup\_stm32f2xx.S} on
tegelikult peaaegu täpselt samasugused. Neid on kaks tükki, sest alglaadur peab
töötama kahel erineval mikrokontrolleril. Neis failides on kirjas
katkestusvektorite tabel, mis on kasutatavatel mikrokontrolleritel erinev.
Lisaks sellele on neis failides põhiline andmete \gls{sram}i kopeerimine,
\gls{sram}i nullide kirjutamine ja C-koodis oleva \textit{main}i väljakutsumine,
millest oli juttu alapeatükis~\ref{sec:boot:tava}.

\subsubsection{Süsteemi päised --- \textbf{stm32fxxx.h}}
\label{sec:comp:sysheader}
Päised \textbf{stm32f10x.h} ja \textbf{stm32f2xx.h} on mikrokontrolleritele
STM32F103 ja STM32F217 vastavad abifailid, milles on defineeritud eeltöötluse
makrod ja struktuurid, mis teevad riistvaramoodulite registrite kasutamise
oluliselt lihtsamaks. Need failid on saadaval mikrokontrolleri tootja käest.

\subsubsection{Cortex-M3 päis --- \textbf{core\_cm3.h}}
\label{sec:comp:core}
Selles päises on defineeritud protsessorituumaga seotud registritele
juurde\-pää\-se\-mist abistavad makrod ja struktuurid. Lisaks sellele on seal
prototüübid funktsioonidele, mis annavad C-koodist juurdepääsu spetsiaalsetele
masinkoodi käskudele, mida kompilaator omapead ei kasuta. Päisega käib koos
realisatsioonifail \textbf{core\_cm3.c}, kus on antud realisatsiooni
nendele spetsiaalsetele käskudele kasutades selleks C-faili kirjutatavat
assemblerit. Nii päis kui ka realisatsioon on saadaval Cortex-M3
protsessorituuma disainijalt ARM Holdings-ilt.

\subsubsection{Peamine päisfail --- \textbf{bootloader.h}}
Esimese asjana kaasab see päis endaga vastavalt eeltöötluse muutujatele õige
süsteemi päise. Kuna peaaegu kõik teised C-failid kaasavad selle faili, saavad
nad nii ka ligipääsu õigetele süsteemi päisetele, mille abil
riistvaramoodulitega suhelda. Lisaks sellele on antud failis prototüübid
kõikidele alglaaduris kasutatavatele funktsioonidele, mida kasutatakse
väljaspool funktsiooni defineeriva faili skoopi. Tavalised tehakse küll nii, et
ühe tarkvaramooduli kohta on üks päisfail ja üks realisatsioonifail, aga nii
oleks tekkinud palju lühikesi päisfaile, mis teevad koodi lugemise asjatult
raskemaks.

\subsubsection{Põhifunktsionaalsus --- \textbf{bootloader.c}}
Selle failis on realiseeritud alglaaduri põhifunktsionaalsus. Seal on
protseduurid kindlal aadressil oleva tarkvara alglaadimiseks, tarkvara
kopeerimise käsu ja kindlas pesas oleva tarkvara alglaadimise käsu täitmiseks.

\subsubsection{Sisemise välkmäluga opereerimine --- \textbf{flash.c}}
Failis on realiseeritud välkmälu kustutamine ja programmeerimine.
Lugemist pole vaja, sest välkmälu asub mikrokontrolleri aadressiruumis ja sealt
lugemine tähendab lihtsalt mingilt aadressilt lugemist. Realisatsioon
abstraheerib ära mikrokontrollerite erinevused.

\subsubsection{\texorpdfstring{\iic}{I2C} FRAMiga suhtlemine --- \textbf{fram.c}}
Fail realiseerib \gls{i2c} suhtluse välise \gls{fram}iga. Antud fail töötas nii
\gls{cdhs}il kui ka \gls{cam}il, kuid hiljem selgus, et \gls{cdhs}i peal peab
siiski kasutama \gls{spi} siinil olevat \gls{fram}i. Sellest ajast on ka faili
nimi lihtsalt viide mälu tüübile. Hiljem lisandus kood ka \gls{spi} siinil
oleva \gls{fram} jaoks. Fail on kasutusel ainult \gls{cam}il.

\subsubsection{SPI FRAMiga suhtlemine --- \textbf{fram\_spi.c}}
Failis on realiseeritud samad funktsioonid \gls{fram}iga suhtlemiseks, kuid seda
üle \gls{spi} andmesiini. Fail on kasutusel ainult \gls{cdhs}il.

\subsubsection{Sisend/väljund viikude seadmine --- \textbf{gpio.c}}
Antud fail lülitab sisse lisaseadmed neile tööks vajaliku kellasignaali lubades,
seadistab sisend-/väljundviigud ja määrab need vajadusel riistvaramoodulitele.
Samuti on seal funktsioonid tarkvara valimise viigu lugemiseks ja südamelöögi
tekitamiseks. Antud failis on vastavad funktsioonid mõlemale mikrokontrollerile,
kuid need erinevused on ära abstraheeritud.

\subsubsection{Alglaaduri logimine --- \textbf{logging.c}}
Fail realiseerib funktsionaalsuse, mis on kirjeldatud
alapeatükis~\ref{sec:impl:log}.

\subsubsection{Alguspunkt --- \textbf{main.c}}
Siin failis asub \textit{main} protseduur, mis initsialiseerib kõigepealt
sisend-/väljund\-viigud, logi ja välise \gls{fram}iga suhtlemiseks vajaliku
\gls{spi} või \gls{i2c} mooduli. Seejärel kontrollib protseduur alglaaduri enda
kontrollsummat. Pärast seda täidab \textit{main} käskude loendis olevad käsud ja
lõpetuseks teeb vaikimisi alglaadimise.

\subsubsection{Testid --- \textbf{tests.c}}
Fail koosneb mõnedest funktsioonidest, mida kasutati testimisel. Alglaaduris
neid tegelikult vaja ei ole. Siin on kood \gls{fram}ist kirjutamise ja lugemise
testimiseks, logisse kirjutamiseks ning käskude loendisse testkäskude
kirjutamiseks.

\subsubsection{Linkija skriptid --- \textbf{stm32\_fx\_flash.ld}}
Tegemist on kahe failiga, mida vastavalt platvormile kasutatakse alglaaduri
linkimiseks. Failides on defineeritud mäluregioonid, mis vastavad alglaaduri
logile ja põhitarkvara pesadele, koos muutujatega, et alglaadurist neid regioone
kasutada. Ühe lisana on ka pärast alglaaduri koodi-, andme- ja
nullidesektsiooni koht ka alglaaduri enda kontrollsumma jaoks.

\subsection{Alglaaduri abiteek}
Alglaaduri abiteek koosneb ühest päisfailist ja ühest C-failist, mis realiseerib
päises kirjeldatud funktsioonid. Abiteek on tehtud selleks, et lihtsustada
ülejäänud tarkvaral alglaaduriga suhtlemist. Alglaadur kasutab ise ka abiteeki,
sest seal on funktsioone, mida peaksid kasutama nii põhitarkvara kui ka
alglaadur. Näiteks käskude loendi lugemine on tegevus, mida võiks saada teha
välimine tarkvara käskude loendi kontrollimiseks ja alglaadur ise käskude
täitmiseks.

Abiteegis on funktsioonid käskude loendi lugemiseks ja muutmiseks. Kuna käskude
loend asub välimises \gls{fram}is, siis on abiteegil vaja funktsioone, et
\gls{fram}i lugeda ja kirjutada. Samas on teada, et nii alglaaduris kui ka
põhitarkvaras, mis mõlemad abiteeki kasutavad, on olemas juba funktsioonid selle
jaoks. Seega on mõistlik kasutada juba olemasolevaid funktsioone ka abiteegis.
Levinud viis on selleks kasutada funktsiooniviitasid, mis kaasa antakse, kuid
nendest loobuti. Alglaaduri päises defineeriti lihtsalt funktsioonide prototüübid.
Kasutades funktsiooniviitasid oleks vea korral probleem tekkinud programmi töö
käigus, aga käesoleva lahenduse korral tuleb viga välja juba linkimise faasis:
kui prototüüpidele vastavate funktsioonide realisatsiooni ei leita, siis annab
linkija veateate.

\section{Töö käik}
Siin peatükis on kirjeldatud teised sarnased lahendused, töö käigus tekkinud
probleemid ja alglaaduri testimine.
\subsection{Sarnased lahendused}
Enne koodi kirjutamist tutvuti STMicroelectronicsi tehtud näidislahenduse ja
selle lähtekoodiga \cite{f1IAP}. Samuti tutvuti ka STM32F2XX seeria jaoks tehtud
näidisprojektiga \cite{f2IAP}, mis oli põhiosas samasugune eelnevaga.

Nendest lähtekoodidest võeti ka jaotises~\ref{sec:comp:sysheader} kirjeldatud
süsteemi päised ning sellele järnevas jaotises~\ref{sec:comp:core}
kirjeldatud failid.

\subsection{Suurimad probleemid}
Siin peatükis on väljatoodud mõned enim aega kulutanud probleemid.
\subsubsection{Viga päises}
Mikrokontrolleri riistvaraga suhtlemine käib läbi juht- ja staatusregistrite,
mis asuvad programmi aadressiruumis. Lihtsustamaks nendega suhtlemist teevad
mikrokontrolleri tootjad C päisfailid, kus on iga mooduli jaoks defineeritud
selle registrite aadressid. Nii ei pea igaüks uuesti oma koodis seda ise tegema,
vaid kasutab olemasolevaid päisfaile. See muudab ka kirjutatava koodi
loetavamaks.

Töö autor kopeeris alglaaduri jaoks need registrite nimesid ja aadresse siduvad
päisfailid STMicroelectronics-i näidisprojektidest \cite{f1IAP,f2IAP}. Testides ja
realiseerides \gls{i2c} suhtlust \gls{cam}i prototüübil, tekkis probleem, et
asi lihtsalt ei töötanud. Pärast mitmeid tunde vea otsimist leiti, et
sisend-/väljundviigud ei ole õigesti seadistatud: \gls{i2c} moodul ei saanud neid
kasutada. Kui kõik teised veakohad olid välistatud, avastati vea tegelik põhjus.
Nimelt oli viga tootja poolt tehtud päises. Viikude seadmistamisega
riistvaramoodulile seotud registrile vahetult eelneva registri suurus oli päises
32 bitti, kuid manuaalis oli kirjas, et see on 16-bitine register. See tähendas,
et vajalikust registrist kirjutati 16 biti võrra mööda.
\subsubsection{\textit{Chip Write Enable}}
Kui \gls{i2c} suhtlus \gls{cam}i prototüübil toimima saadi ja suhtlus
\gls{fram}iga toimus, siis asuti seda sama tegema ka \gls{cdhs}i plaadil.
Riistvaraline \gls{i2c} moodul ise oli küll samasugune, aga
sisend-/väljundviikude seadistamine oli natuke erinev. Tundus nagu asi töötaks,
aga \gls{fram}i kirjutades ja siis lugedes ei olnud tagasiloetavad andmed samad,
mis sinna kirjutati.

Tagantjärele oli vea põhjus suhteliselt ilmne, kuid sellegipoolest kulus palju
aega enne, kui veale jällile jõuti. Nimelt oli kasutataval \gls{fram}i kiibil
eraldi jalg, mis pidi olemas kindlas asendis, et \gls{fram}i kirjutamine
töötaks. \gls{cam}i plaadil oli see jalg jäädavalt õigesse asendis, aga
\gls{cdhs}i peal oli see viik ühendatud mikrokontrolleri viigu külge ja nii pidi
tarkvara selle viigu enne kirjutamist \gls{fram}i õigesse asendisse panema.

\subsubsection{\textit{SPI slave select}}
Kui selgus, et on vaja \gls{cdhs}i peal kasutada \gls{spi} siinil olevat
\gls{fram}i, esines ka selle realiseerimisel kaks rohkem silumiseks aega võtnud
probleemi. 

Esimesel katsel pärast paaritunnist katse-eksitusmeetodil üritamist avastas
autor, et kasutataval prototüübil polnud \gls{spi} siinil \gls{fram}i kiipi.
Kiip oli lihtsalt trükkplaadile jootmata jäänud, kuid see ei olnud ainus
probleem, mis aega võttis.

Kuna töö autorile öeldi ainult alglaaduri tööks vajaminevate asjade
kohta, siis jäi \gls{spi} siinil olevate teiste seadmete \textit{slave select}
viigud seadistamata. Ostsillograafiga \gls{spi} suhtlust vaadates leiti, et
tagasitulevad andmed on küll väga imelikud, kuid neis on mingi loogiline
struktuur. Tuli välja, et \gls{spi} siinil olev reaalajakell üritas samal ajal
koos \gls{fram}iga andmeid tagastada. Probleemi lahendus oli jällegi lihtne:
määrati kõigi \gls{spi} siinil olevate seadmete valimise viigud mitteaktiivseks.
Alglaaduri töö ajal muudeti ainult \gls{fram}iga suhtlemise ajaks
\gls{fram}ile vastavat seadme valimise viigu väljundit.

\subsection{Testimine}
Testimiseks ja silumiseks kasutati mikrokontrolleril olevat silumise süsteemi,
millega suheldi kasutades Seggeri JTAGi \cite{jtag,jtagwiki} emulaatorit J-Link
\cite{jlink}. Kuna \gls{cam}i prototüübil polnud JTAGi liidese jaoks kõik
signaalid väljatoodud, kasutati seal vähemate signaalidega \textit{Serial Wire
Debug} (SWD) liidest, sest nendele signaalidele oli juurdepääs olemas.

Siluriks kasutati \textit{The GNU Project Debbugger}it (GDBd). J-Link ja GDB
võimaldasid:
\begin{itemize}
	\item suvalises kohas mikrokontrolleri töö peatada,
	\item lugeda ja kirjutada \gls{sram}i,
	\item lugeda ja kirjutada riistvaramoodulite juhtimiseks kasutatavatesse
		registritesse,
	\item väljakutsuda funktsioone,
	\item pärast muudatuste tegemist mikrokontrelli tööd jätkata pooleliolevast
		kohast.
\end{itemize}
Siluri abil sai simuleerida erinevaid süsteemi olekuid ja nii said kõik erinevad
koodirajad vähemalt korra käivitatud.

Alglaaduri integreerimisega tegelesid \gls{cdhs}i ja \gls{cam}i arendajad.

\section{Teadaolevad vead}
Käesoleva dokumendi kirjutamise ajal on ESTCube-1 juba Maa orbiidil ja enam ei
jää üle muud, kui vead lihtsalt dokumenteerida.  \subsection{Puuduoleva tarkvara
tõmmise kontrollsumma arvutamine} Kui juhtub, et alglaadur tahab kontrollida
tühjas välkmälu pesas oleva tarkvara tõmmise kontrollsummat, siis loetakse
päisest, et tarkvara suurus on 0xFFFF FFFF baiti ja hakkab seda arvutama.
Tegelikult tuleks kontrollida, et tarkvara oleks mõistlikku pikkusega. Sobivaks
maksimumiks oleks näiteks tarkvarapesa maksimaalne pikkus.

Sama probleem esineb ka siis, kui enne \gls{fram}ist välkmällu kopeerimist hakatakse
kontrollima \gls{fram}is oleva tarkvara tõmmise kontrollsummat.

\subsection{Südamelöögi genereerimine}
Südamelöögi genereerimisel on kaks probleemi, millest esimene on lihtne
lohakusviga. Nimelt jäi \gls{cam}i versioonil südamelöögi signaali
genereerimiseks kasutataval funktsiooni keha tühjaks. Seega \gls{cam}i peal ei
genereeri alglaadur ühtegi lööki.

Teine probleem tuleneb sellest, et lõppfaasis oli vaja \gls{cdhs}i peal
\gls{fram}iga suhtlus ümber teha \gls{spi} andmesiini peale. Seetõttu jäi
\gls{spi} \gls{fram}i koodi südamelöögi signaali genereerimine lisamata. See
võib olla probleem, kui kopeerimise käsu ajal kõigepealt välises
\gls{fram}is oleva tarkvara tõmmise kontrollsummat arvutatakse ja selle vältel
ühtegi südamelöögi signaali ei genereerita.

Nende kahe probleemi leevendamiseks võib öelda, et alglaaduri tegemise ajal
polnud toitesüsteemis südamelöögi jälgimine veel realiseeritud. Selle dokumendi
kirjutamise ajal on aga selge, et see funktsionaalsus polegi vajalik. Nimelt
otsustati, et tarkvara töötamisest saab paremini aru, kui moodul vastab
toitesüsteemi poolt saadetud päringule. Päringu saatmise periood on piisavalt
pikk, et alglaadur jõuab oma töö lõpetada ja seetõttu ei pea alglaadur ise
nendele päringutele vastama.

\label{sec:prob:beat}
\section{Mida tulevikus paremini teha?}
\subsection{Programmi ettevalmistamine}
Alapeatükis~\ref{sec:boot:prep} kirjeldati, miks on vaja programm linkida
kindlale mälu\-aadressile. Samas on teada, et kompilaatorid suudavad genereerida
ka koodi, mis ei sõltu positsioonist. Üheks järgmiseks uurimissuunaks on
kontrollida, kas see töötab nagu soovitud. Katkestusvektorite tabelis on ikkagi
absoluutsed aadressid, kuid alglaadur võib tarkvara kopeerimise ajal ise need
aadressid siis vastavalt programmi asukohale transleerida. Nii oleks võimalik
kasutada ühte satelliidile üleslaaditud tarkvara tõmmist nii sisemise välkmälu
primaarses kui ka sekundaarses pesas.

Hetkel kasutavad nii alglaadur ise, kui ka alglaaduriga suhelda tahtev programm
alglaaduri abiteeki. See tähendab, et abiteek on nii alglaaduri kui ka
põhitarkvara tõmmises ehk abiteek on välkmälus korduvalt. Tulevikus võib
kaaluda sellist lähenemist, et abiteek on alglaaduri osa ja põhitarkvara
linkimisel öeldakse, millistelt aadressidelt abiteek kätte saadakse. Sellisel
juhul ei oleks vaja abiteeki mitmekordselt hoiustada.

\subsection{Polsterduse eemaldamine}
Alapeatükis~\ref{sec:impl:header} sai mainitud, et tarkvara tõmmise ja
päise vahel on 500 baiti polsterdust, mis raiskab mäluseadmetes ruumi. Tulevikus
tasub uurida, kuidas see polsterdust eemaldada.

\subsection{Enne juhtimise üleandmist algseisu taastamine}
Alglaadur kasutab mõnda riistvaramoodulit ja muudab selle käigus nende
juhtregistrite sisu algväärtusest erinevaks. Kui alglaaditav programm eeldab,
et algväärtus on kindel ja ei tee ise alguses moodulile resetti algväärtuste
taastamiseks, siis programm töötab iseseisvalt, aga mitte koos alglaaduriga.

Alglaaduris tehakse enne mooduli seadistamist moodulile alglähtestamine, et olla
kindel, et mooduli registrites oleksid teadaolevad algväärtused. Samamoodi
tuleks kõigile kasutatavatele moodulitele teha alglähtestamine ka enne
alglaaditavale programmile juhtimise üleandmist.

\section{Kokkuvõte}
Käesoleva töö raames loodi satelliidi ESTCube-1 kahele alamsüsteemile alglaadur,
mis võimaldaks nende tarkvara töö käigus uuendada. 

Alglaadurit on pidevalt tarkvara uuendamiseks kasutatud, sest pärast satelliidi
komplekteerimist polnud võimalik teisel viisil nende moodulite tarkvara
uuendada. Viimane uuendus tehti enne satelliidi orbiidile viimist Kourous.
Orbiidil olles on alglaadur alglaadinud \gls{cdhs}i tarkvara.  Lähitulevikus
lülitatakse sisse ka \gls{cam}. Siiamaani pole orbiidil nende alamsüsteemide
tarkvara uuendatud, kuid Maa peal on seda korduvalt tehtud.

Kokkuvõtvalt said töö eesmärgid täidetud ning töö lõpp-produkt on Eesti esimesel
satelliidil ESTCube-1 reaalselt kasutusel.

\newpage
\section*{Bootloader for ESTCube-1 Command and Data Handling System and Camera module}
\addcontentsline{toc}{section}{Summary}
\begin{center}
\bf Bachelor Thesis (6 ECTS)\\
Karl Tarbe\\
Summary
\end{center}
Estonian first satellite ESTCube-1 consists of several modules. The main
on-board computer Command and Data Handling System (CDHS) and Camera module
(CAM) have similar micro controller units (MCUs): CDHS uses STM32F1 and CAM STM32F2
series micro controllers manufactured by STMicroelectronics.  The goal of this
thesis is to design and implement a bootloader, which enables software upgrading
for \gls{cdhs} and \gls{cam}, while ESTCube-1 is orbiting Earth.

The bootloader does not have to communicate with ground station. It is assumed
that main firmware will store new firmware image in external \gls{fram} and then
orders bootloader to copy it to MCU's internal flash memory. External
\gls{fram} is accessed either over \gls{spi} or \gls{i2c} bus.

For the main firmware to give commands to bootloader a command list is stored in
external \gls{fram}. Firmware writes commands to there and then reboots the MCU.
After MCU reset, bootloader is always started. Bootloader reads the command
list and executes given commands before bootloading the main firmware.

Bootloader was implemented as 2 Eclipse projects. First for the bootloader itself
and second for a utility library, which the main firmware can use to modify the
command list and read logs produced by bootloader.

So far bootloader has been used many times to upgrade firmware or to boot into
the main firmware. Bootloader has also successfully booted \gls{cdhs} while
ESTCube-1 is on low Earth orbit. While the satellite has been orbiting Earth,
there has been no firmware upgrades yet.

In conclusion the goals of this thesis were achieved and the end-product is
actually used on the first Estonian satellite ESTCube-1.
\newpage

\section*{Tänusõnad}
\addcontentsline{toc}{section}{Tänusõnad}
Indrek Sünter oli see inimene, kes oli autori kontaktisik satelliidi meeskonnas.
Tema tegeles \gls{cdhs}i põhitarkvara kirjutamisega ja seega oli tema põhiline
,,klient'', kelle vajadusi alglaadur rahuldama pidi. Ta aitas arutada ja nõudeid
paika panna, samuti luges ta elektriskeemidelt ette vajalikud
sisend-/väljund\-viigud ning aitas prototüüpide ühendamisel. Suured tänud talle!

Lisaks saab tänu osaliseks autori hea sõber Mihkel Heidelberg, kes autorile selle
teema soovitas.

\newpage
\phantomsection
\addcontentsline{toc}{section}{Viited}
\label{viited}
\bibliographystyle{unsrt}
\bibliography{viited}

\section*{Lisa 1}
\addcontentsline{toc}{section}{Lisa 1}
Käesoleva töö käigus valminud alglaaduri ja selle abiteegi lähtekoodid on
kättesaadavad ESTCube-1 meeskonnalt. Alternatiivselt on lähtekood üleslaetud ka
Tartu Ülikooli Arvutiteaduse instituudi lõputööde registrisse käesoleva
bakalaureuse töö lisana. Register on asub aadressil
\url{http://comserv.cs.ut.ee/forms/ati\_report/index.php} .

\newpage
\section*{Lihtlitsents lõputöö reprodutseerimiseks ja lõputöö üldsusele
kättesaadavaks tegemiseks}

Mina Karl Tarbe (sünnikuupäev: 20.02.1991)
\begin{enumerate}
	\item
		annan Tartu Ülikoolile tasuta loa (lihtlitsentsi) enda loodud teose\\
		,,Alglaadur ESTCube-1 käsu- ja andmehaldussüsteemile ja
		kaameramoodulile'',\\
		mille juhendaja on Meelis Roos,
		\begin{enumerate}
			\item 
				reprodutseerimiseks säilitamise ja üldsusele kättesaadavaks
				tegemise eesmärgil, sealhulgas digitaalarhiivi DSpace-is
				lisamise eesmärgil kuni autoriõiguse kehtivuse tähtaja
				lõppemiseni;
			\item
				üldsusele kättesaadavaks tegemiseks Tartu Ülikooli
				veebikeskkonna kaudu, sealhulgas digitaalarhiivi DSpace'i kaudu
				kuni autoriõiguse kehtivuse tähtaja lõppemiseni.
		\end{enumerate}
	\item
		olen teadlik, et punktis 1 nimetatud õigused jäävad alles ka autorile.
	\item
		kinnitan, et lihtlitsentsi andmisega ei rikuta teiste isikute
		intellektuaalomandi ega isikuandmete kaitse seadusest tulenevaid õigusi.
\end{enumerate}

Tartus, \textbf{07.05.2013}

\end{document}
