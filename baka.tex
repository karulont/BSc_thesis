\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[estonian]{babel}
\usepackage{cite}

\title{Alglaadur ESTCube-1 käsu- ja andmehaldussüsteemile ja kaameramoodulile}
\author{Karl Tarbe}


\newcommand{\iic}{I\({}^2\)C }

\begin{document}
\begin{titlepage}
\begin{center}
Tartu Ülikool\\
Matemaatika-informaatika teaduskond\\
Arvutiteaduse intituut\\
Informaatika eriala
\vfill
Karl Tarbe\\[1cm]
Alglaadur ESTCube-1 käsu- ja andmehaldussüsteemile ja kaameramoodulile\\[4mm]
Bakalaureusetöö (6 EAP)
\vspace{2cm}
\begin{flushright}
	Juhendajad: Meelis Roos\\
	Helle Hein
\end{flushright}
\vfill
Tartu 2013
\end{center}
\end{titlepage}
\tableofcontents

\section{Sissejuhatus}
Aasta 2008 suvel alustati tudengisatelliidi projektiga. Esialgu pidi tegemist
olema väga lihtsa satelliidiga, kus peal on võib-olla üks või kaks
mikrokontrollerit, kuid asjad nii ei läinud. Inseneridele meeldib ikka üle
töötada ja asju paremaks teha. Nii sai ka eesti esimesest satelliidist päris
keeruline süsteem, mis koosneb mitmetest moodulitest. Kuna tegemist on üpris
keerulise süsteemiga peab ka selle juhtimiseks kasutatav tarkvara keeruline
olema ja iga keerulise tarkvara puhul esineb tavaliselt vigu. Siinkohal muutubki
aktuaalseks alglaadur, mille abil saab tarkvara uuendada.

\subsection{Estcube-1}
\subsubsection{Missioon}
\subsection{Käsu- ja andmehaldussüsteem - CDHS}
\textit{Command and Data Handling System} ehk käsu- ja andmehaldussüsteem on
kavandatud satelliidi peamiseks pardaarvutiks. Peamised arvutused, mis määravad
satelliidi positsiooni, toimuvad just CDHSis. CDHSi salvestatakse igasugu
erinevaid andmeid, mida sõltuvalt maapealt tulevatele käskudele ka tagastatakse.

Süsteem koosneb nii tarkvarast kui ka elektroonikast, mille peal tarkvara
jooksutatakse. Antud bakalauresetöö raames pole põhitarkvara detailid eriti
olulised, aga elektroonika on natuke oluline. Nimelt kuuluvad CDHSi juurde ka
mitmed mälud, kus hoitakse erinevaid andmeid. Nendest mäludest oluliseks on
Ferroelektrilised juhupöördusega mälud (FRAM), sest need on radiatsioonirikkas
keskkonnas mitu korda töökindlamad kui tavapärased välkmälud (FLASH). Täpsemalt
on mäludest juttu peatükis~\ref{sec:m2lud}.

Protsessorituumaks on ARM Cortex-M3, mis paikneb STMicroelectronics-i poolt
valmistatud mikrokontrolleris STM32F103, millest tuleb lähemalt juttu
peatükis~\ref{sec:mcu}. Üheks märkimisväärseks omaduseks CDHSi puhul on see, et
süsteemis on osaline riistvaraline dubleeritus: trükkplaadil on kaks identset
mikrokontrollerit. Esialgu jookseb neist üks, kuid kui tuvastatakse, et see
mikrokontroller enam ei tööta, lülitatakse ümber teisele mikrokontrollerile.
Selle vea tuvastamise ja ümberlülitamise eest vastutab toitesüsteem. Lülitatakse
ümber ka andmesiinid, sest mikrokontrollerist väljajäävad seadmed on korraga
ühenduses ainult ühe mikrokontrolleriga.

\subsection{Kaameramoodul - CAM}
Kaameramooduli ülesandeks on teha pilte kontrollimaks, kas päikesepurje
veljakerimine õnnestub nii nagu soovitud. Sekundaarne ülesanne on teha maast ja
ka eestist pilte, mida saaks kasutada teaduse populariseerimise eesmärgil.
Pilte saab teha VGA resolutsioonis ehk 640\(\times\)480 pikslit, mida on üldises
mõttes küll väga vähe, kuid loodetavasti piisavalt, et etteantud ülesandeid
täita.

Sarnaselt CDHSiga juhib mooduli tööd mikrokontroller, mille tootjaks on
STMicroelectronics. Mikrokontrolleriks on STM32F217, mis laias laastus ei erine
eriti CDHSi peal kasutatavast STM32F103st, kuid nendest erinevustest lähemalt
saab lugeda peatükist~\ref{sec:mcu}.

Teine sarnasus CDHSiga on see, et ka CAMil on mikrokontrollerist väljajäävad
mälud. Täpsemalt on alglaaduri jaoks oluline, et CAMil asub FRAM tüüpi mälu,
millega mikrokontroller saab suhelda üle \iic andmesiini.

\subsection{Mikrokontrollerid STM32F103 ja STM32F217}
\label{sec:mcu}

\subsection{Mälud}
\label{sec:m2lud}
SRAM
FRAM vs FLASH

\section{Süsteemi nõuded}

\section{Alglaadimine}
\subsection{Tavapärane alglaadimisprotseduur}
Kui mikrokontrolleril toide olemas on üritab see ennast tööle panna.
Esmalt lülitatakse sisse sisemine 8-MHz-ne ossillaator, mille signaali
neljandal tõusval frondil loetakse konfigureerimise viikude väärtused. Nende
väärtuste põhjal otsustatakse, millisest kohast alglaadida. Võimalikud
variandid on: põhi välkmälu, süsteemi mälu ja staatiline juhupöördlusega
mälu(SRAM).  Enim kasutatakse kahte esimest: põhi välkmälu seal oleva programmi
käivitamiseks ja süsteemi mälu, et põhimälu muuta. Tehases paigaldatakse
süsteemi mällu, mis on tegelikult lihtsalt üks kaitstud osa põhi välkmälu
lõpust, alglaadur, mille abil saab programmeerida ülejäänud välkmälu ehk oma
programmi mikrokontrollerile laadida.

Oletades, et programm on juba kiibi välkmälus olemas ja alglaadimist
alustatakse põhi välkmälust, vaatleme edasist protsessi. Välkmälu aadress on
tegelikult 0x800 0000, aga viikude oleku tõttu peegeldatakse see ka aadressile
0x0000 0000, kust protsessor oma tööd alustab.  Protsessor võtab aadressil
0x0000 0000 oleva väärtuse ja seab selle pinu ülemiseks väärtuseks. Seejärel
alustatakse instruktsioonide täitmist lähtestamise vektorist, mille
algusaadress on kirjas aadressil 0x0000 0004. \cite{f1rm}

Lähtestamise vektoril on tavaliselt assembleris kirjutatud protseduur, mis
kopeerib programmi andmete sektsiooni välkmälust SRAMi, täidab ülejäänud
programmi jaoks vajaliku ala SRAMist nullidega, kutsub välja C koodis kirjutatud
protseduuri, mis initsialiseerib süsteemi kella, ja siis annab juhtimise üle C
koodis kirjutatud \textit{main} protseduurile. Satelliidi peal ei kasutata
üldist kella seadmise koodi ja seega see samm jäetakse vahele ning kella
seadmine kutsutakse välja \textit{main}ist.

See, mida tarkvara edasi initisaliseerib, on juba tarkvara spetsiifiline.
Tõenäoliselt initsialiseeritakse mõned riistvaralised moodulid näiteks USART või
SPI ja hakatakse siis rakendusele vajalikku kontrolltsüklit täitma. Satelliidil
Estcube-1 kasutatakse nii CAMil kui ka CDHSil reaalaja operatsioonisüsteemi
FreeRTOS.

\subsection{Programmi alglaadimine koos alglaaduriga}
Alglaadur ise käitub alglaadimise seisukohalt nagu iga teinegi programm ja
laetakse täpselt samamoodi nagu eelmises alapeatükis kirjeldatud. See tähendab
seda, et alglaaduri katkestusvektorite tabel peab asuma välkmälu alguses, sest
sealt hakkab protsessor seda otsima. Kuna üks osa alglaadurist asub juba
välkmälu alguses, on ka teised osad sinna järele paigutatud, mis omakorda
tähendab, et tegelik põhiprogramm peab nüüd asuma kusagil mujal kui välkmälu
alguses ja sellega peab arvestama põhiprogrammi linkimisel.

Kui alglaadur on oma muud ülesanded juba täitnud, on tema viimaseks tööks
põhitarkvara käivitamine. Selleks käitub sarnaselt protsessoriga, kuid
kõigepealt on tal vaja teada, mis aadressil põhitarkvara katkestusvektorite
tabel asub. See aadress on aga eelnevalt kokkulepitud ja sissekodeeritud.

Enne põhitarkvara töölepanemist tuleks puhtaks teha pinu. Alglaaduri enda töö
ajal sinna salvestatud väärtusi pole põhiprogrammil kohe kuidagi vaja. Pinu
puhtaks tegemine tähendab lihtsalt pinu viida algväärtustamist, sest nii
hakatakse edaspidi pinus juba olevaid andmeid üle kirjutama ja kui programm on
korrektne, siis midagi sellist ei loeta, mida programm ise pole juba üle
kirjutanud. Algväärtustamiseks kasutatakse põhitarkvara katkestusvektorite
tabeli esimest elementi, mis näitas pinu ülemist aadressi.

Kuigi mikrokontrolleri käivitamise hetkel alustatakse tööd kindlast kohast, ei
pea terve katkestusvektorite tabel välkmälu alguses olema. Katkestustega tegeleb
eraldi riistvara moodul NVIC (\textit{Nested Vectored Interrupt Controller}).
Lisaks on sellega tihedalt seotud teine moodul SCB (\textit{System Control
Block}), kus asub seadistatav register VTOR (\textit{Vector Table Offset
Register}), mille väärtust kasutatakse katkestusvektorite tabeli aadressina.
\cite[ptk~4.4]{CM3pm} Vaikimisi on seal väärtus 0x0000 0000, mida kasutatakse alglaaduri
laadimiseks, kuid alglaadur seab selleks väärtuseks põhiprogrammi
katkestusvektorite tabeli aadressi. Kui seda ei seadistataks, siis kutsutaks
põhiprogrammi katkestuse ajal välja alglaaduri katkestusvektoreid, mis on
tegelikult implementeerimata, sest alglaadur ei kasuta katkestusi, ja nii ei
saaks põhitarkvara oma ülesandeid täita. Lisaks sellele on vaikimisi katkestuse
teenindamise rutiin lihtsalt lõputu tsükkel, seega jääks kontroller katkestusse
kinni ja halvatud ei oleks ainult põhitarkvara katkestuse teenindamine vaid kogu
põhitarkvara töö peatuks.

Kui pinu viit ja katkestusvektorite tabeli asukoht on ära seadistatud jääb üle
veel lugeda katkestusvektorite tabelist põhiprogrammi lähtestamise vektori
aadress ja mikrokontrolleri töö sinna edasi juhtida. Selleks tehakse C-koodis
funktsiooni viit, mis väärtustatakse lähtestamise vektori aadressiga ning
seejärel kutsutakse see välja.

Edasine toimub sarnane tegevus nagu tavapärase alglaadimise juures, kus
lähtestamise vektoril olev kood kopeerib välkmälus oleva põhiprogrammi andmete
sekstsiooni SRAMi, tähendab SRAMi initsialiseerimata andmete jaoks ja seejärel
kutsub välja põhitarkvara \textit{main} protseduuri.


\section{Komponendid}

\section{Kokkuvõte}

\section{Resume}

\bibliographystyle{plain}
\bibliography{viited}

\end{document}
